\chapter{Implementacja generatora} \label{chap:implementation:single_type}

Generator aplikacji konkretnego typu będzie korzystał z~trzonu narzędzia w~celu wygenerowania części aplikacji opartej o~architekturę CQRS, korzystającej z~wzorca Event Souring i~z~bazy danych Cassandra.
Głównym celem generatora jest wyeliminowanie z~systemu duplikacji opisu dziedziny aplikacji.
Zostanie to osiągnięte przez umieszczenie pełnego opisu dziedziny w~jednym miejscu i na jego podstawie~generowanie innych artefaktów systemu, które duplikowałyby wiedzę na temat dziedziny.

W~celu przestawienia kolejnych kroków implementacji narzędzia, sformułowany zostanie przykład generowanej aplikacji.



%=======
\section{Przykład generowanej aplikacji}
%=======

Przykładowa aplikacja będzie serwisem internetowym, który umożliwia użytkownikom prowadzenie blogów.
Użytkownik serwisu (encja $User$) będzie mógł:

\begin{itemize}
 \item dodać wpis na swoim blogu (encja $Post$);
 \item polubić wpis innego użytkownika (encja $Like$);
 \item skomentować wpis innego użytkownika (encja $Comment$);
 \item skomentować komentarz innego użytkownika.
\end{itemize}

Dziedzina serwisu została przedstawiona na rysunku~\ref{fig:single:domain_normalized}.
Dziedzina ta reprezentuje jednocześnie model komend systemu.
Należy zaznaczyć, że na potrzeby przykładu dziedzina została w~jak największym stopniu uproszczona (np. nie znalazła się w~niej encja $Blog$, która mogłaby przechowywać nazwę, opis i~logo bloga).

\input{figures/implementation_single/domain_normalized}

Na potrzeby architektury CQRS należy także zdefiniować model zapytań.
Elementy wchodzące w~skłąd tego modelu nazywane będa widokami.
Widoki powinny udostępniać dane zdenormalizowane w~takim stopniu, aby umożliwić jak najefektywniejsze wykonywane najczęstszych zapytań wykonywanych w~systemie~\cite{cassandra_model}.

W~omawianym przykładzie najczęściej wykonywane będa zapytania na potrzeby:

\begin{itemize}
 \item wyświetlania danego bloga, tzn. wszystkich wpisów jego autora wraz z~liczbą ich komentarzy - w~tym celu wykonane zostanie pojedyncze odwołanie do widoku $Post$;
 \item wyświetlania danego wpisu wraz z~jego komentarzami i~``polubieniami'' - w~tym celu wykonane zostaną odwołania do widków: $Post$, $Comment$ i~$PostLike$;
 \item wyświetlenia profilu użytkownika wraz z~jego ulubionymi wpisami - w~tym celu wykonane zostanie jedno odwołanie do widoku $User$ i~jedno do widoku $UserLike$.
\end{itemize}

Model zapytań został przedstawiony na rysunku~\ref{fig:single:domain_denormalized}.

\input{figures/implementation_single/domain_denormalized}

Pomiędzy znormalizowanym modelem dziedziny (rysunek~\ref{fig:single:domain_normalized}), a~modelem zdenormalizowanym modelem zapytań wystepują dwie istotne różnice:

\begin{enumerate}
 \item Encja $Like$ została rozbita na dwia widoki: $UserLike$ i~$PostLike$.
 Przechowują one dane inne niż tylko identyfikatory powiązanych encji.
 Umożliwia to wykonywanie stałej (równej $2$) liczby zapytań do bazy danych w~celu wyświetlenia profilu użytkownika wraz z~tytułami lubianych przez niego wpisów (lub wyświetlania wpisu wraz imionami i~nazwiskami użytkowników go lubiących).
 Pozostawienie encji $Like$ w~niezmienionym kształcie skutkowałoby potrzebą wykonania w~tym celu $n + 2$ zapytań, gdzie $n$ to liczba wpisów lubianych przez danego użytkownika (lub liczba użytkowników lubiących dany wpis).
 Brak operacji złączenia w~języku CQL uniemożliwia wydobycie wszystkich potrzebnych danych w~jednym zapytaniu.
 \item Widok $Post$ otrzymał pole $CommentsNumber$.
 Umożliwia to wyświetlenie wpisów wraz z~liczbą ich komentarzy bez potrzeby odwoływania się do widoku $Comment$.
 Używając języka SQL, aby uzyskać te dane przy użyciu pojedynczego zapytania, wystarczyłoby wykorzystać złączenie i~funkcję agregującą $Count$.
 Jednakże język CQL nie umożliwia stworzenia takiego zapytania (a~tym samym wymusza jak najmniejszy koszt zapytania).
\end{enumerate}



%=======
\section{Generowane artefakty} \label{sec:generated_artifacts}
%=======

Artefaktami generowanymi na podstawie opisu dziedziny aplikacji będą:

\begin{itemize}
 \item skrypty DLL definiujące strukturę bazy danych;
 \item klasy wchodzące w~skład modelu komend (patrz: sekcja~\ref{sec:cqrs});
 \item klasy wchodzące w~skład modelu zapytań (patrz: sekcja~\ref{sec:cqrs});
 \item klasy reprezentujące zdarzenia zachodzące w~systmie (patrz: sekcja~\ref{sec:event_sourcing});
 \item klasy reprezentujące dane wyświetlane w~interfejscie użytkownika (\emph{view models});
 \item dokumentację systemu w~formacie HTML;
 \item pomocnicze skrypty powłoki automatyzujące rutynowe czynności wykonywane przez programistów (patrz: sekcje~\ref{sec:tasks_dupl}, \ref{sec:tasks_scripts}).
\end{itemize}

We wszystkich tych elementach zazwyczaj powielana jest wiedza na temat dziedziny aplikacji.
Elementy mniej narażone na duplikację dziedziny, takie jak klasy realizujące logikę biznesową aplikacji, nie będą generowane przez narzędzie.



%=======
\section{Sposób definicji dziedziny}
%=======

Zgodnie z~założeniami dotyczącymi implementacji generatora, wszystkie artefakty wymienione w~sekcji~\ref{sec:generated_artifacts} powinny być generowane na podstawie pojedynczego opisu dziedziny aplikacji.
Podczas implementacji tego aspektu pojawiają się następujące problemy:


\subsection{Czy tworzyć schemat opisu dziedziny?}

Problem ten poruszony został w~sekcji~\ref{sec:core:domain_schema_requirement}.
Stwierdzono, że słusznym wyborem jest stworzenie schematu opisu dziedziny aplikacji.
Pozostaje jednak pytanie, gdzie należy ten schemat zdefiniować i~przechowywać.

Nie ulega wątpliwości, że, aby uniknąć duplikacji, schemat opisu dziedziny powinen być zdefiniowany tylko w~jednym miejscu.
Odpowiednim takim miejscem, jako że tam właśnie schemat ten będzie używany, wyjdaje się być klasa należąca do kodu źródłowego generatora aplikacji CQRS.
Gdyby schemat być przechowywany gdzie indziej, odpowiadająca mu klasa i~tak musiałaby być stworzona lub wygenerowana, aby moć zdeserializować dziedzinę do obiektu silnie typizowanego.

\subsection{Schemat opisu dziedziny aplikacji}

zdefiniowanie schematu opisu dziedziny na potrzeby CQRS (zapisać każdy w JSONie)

\subsubsection{per widok}

duplikacje
trudność wygenerowania modelu komend, i zdarzeń

\ref{fig:single:model_perView}
\input{figures/implementation_single/model_perView}

\subsubsection{per encja}

PresentIn
brak duplikacji
encje generują się same, generacja widoków i zdarzeń wymaga trochę pracy, ale jest ok

\ref{fig:single:model_presentIn}
\input{figures/implementation_single/model_presentIn}

\subsubsection{per pole}
po prostu zbiór pól i gdzie występują
brak duplikacji

\ref{fig:single:model_perField}
\input{figures/implementation_single/model_perField}

Wybór 2 rozwiązuje oba problemy postawione na końcu sekcji~\ref{sec:cqrs}.


\subsection{które typy umieścić w definicji?}

które typy umieścić w definicji? CQLowe, .NETowe, czy własne? (nie ma potrzeby własnych, bo trzeba by robić dwie mapy; lepiej CQLowe bo jeden .NETowy mapuje się na wiele CQLowych) (że będzie potrzebna TypesMap.GetDotNetType)


\subsection{organizacja plików wejściowych i wyjściowych}

organizacja plików wejściowych i wyjściowych \ref{sec:core:files_structure}



%=======
\section{Podstawowe jednostki generacji}
%=======

\begin{itemize}
 \item entity
 \item event
 \item view
\end{itemize}



%=======
\section{Implementacja szablonów generacji}
%=======

Implementacja szablonów

\begin{itemize}
 \item CQL:
  \begin{itemize}
   \item create table
   \item select
  \end{itemize}
 \item C\#:
  \begin{itemize}
   \item entity
   \item event
   \item view
  \end{itemize}
 \item HTML (dokumentancja)
\end{itemize}

\ref{fig:single:template_table}
\input{figures/implementation_single/template_table}

\ref{fig:single:template_class}
\input{figures/implementation_single/template_class}

\ref{fig:single:template_docs}
\input{figures/implementation_single/template_docs}



%=======
\section{Implementacja kolejnych modułów aplikacji}
%=======

\begin{itemize}
 \item CQL (create keyspace, create tables (do pojedynczego skryptu inicjalizującego bazę danych)
 \item DAL (repozytorium bazowe zahardkodowane, konkretnych nie da się wygenerować)
 \item BLL (obsługa zdarzeń zahardkodowana, da się wygenerować Eventy, a EventHandlery?)
 \item WEB (Nancy, da się wygenerować ViewModele, formy)
\end{itemize}
