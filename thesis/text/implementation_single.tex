\chapter{Implementacja generatora} \label{chap:implementation:single_type}

Generator aplikacji konkretnego typu będzie korzystał z~trzonu narzędzia w~celu wygenerowania części aplikacji opartej o~architekturę CQRS, korzystającej z~wzorca Event Souring i~z~bazy danych Cassandra.
Głównym celem generatora jest wyeliminowanie z~systemu duplikacji opisu dziedziny aplikacji.
Zostanie to osiągnięte przez umieszczenie pełnego opisu dziedziny w~jednym miejscu i na jego podstawie~generowanie innych artefaktów systemu, które duplikowałyby wiedzę na temat dziedziny.

W~celu przestawienia kolejnych kroków implementacji narzędzia, sformułowany zostanie przykład generowanej aplikacji.



%=======
\section{Przykład generowanej aplikacji}
%=======

Przykładowa aplikacja będzie serwisem internetowym, który umożliwia użytkownikom prowadzenie blogów.
Użytkownik serwisu (encja $User$) będzie mógł:

\begin{itemize}
 \item opublikować wpis (encja $Post$) na swoim blogu (zdarzenie $PostPublishedEvent$);
 \item polubić (asocjacja $Like$) wpis innego użytkownika (zdarzenie $PostLikedEvent$);
 \item skomentować (encja $Comment$) wpis innego użytkownika (zdarzenie $PostCommentedEvent$);
 \item skomentować komentarz innego użytkownika (również zdarzenie $PostCommentedEvent$).
\end{itemize}

Dziedzina serwisu została przedstawiona na rysunku~\ref{fig:single:domain_normalized}\footnote{Należy zaznaczyć, że na potrzeby przykładu dziedzina została w~jak największym stopniu uproszczona (np. nie znalazła się w~niej encja $Blog$, która mogłaby przechowywać nazwę, opis i~logo bloga).}.
Jednocześnie reprezentuje ona model komend systemu.
Natomiast zachodzące w~systemie zdarzenia pokazano na rysunku~\ref{fig:single:domain_events}.

\input{figures/implementation_single/domain_normalized}

\input{figures/implementation_single/domain_events}

Na potrzeby architektury CQRS należy także zdefiniować model zapytań.
Elementy wchodzące w~skład tego modelu nazywane będa widokami.
Widoki powinny udostępniać dane zdenormalizowane w~takim stopniu, aby umożliwić jak najefektywniejsze wykonywane najczęstszych zapytań wykonywanych w~systemie~\cite{cassandra_model}.

W~omawianym przykładzie najczęściej wykonywane będa zapytania na potrzeby:

\begin{itemize}
 \item wyświetlania danego bloga, tzn. wszystkich wpisów jego autora wraz z~liczbą ich komentarzy - w~tym celu wykonane zostanie pojedyncze odwołanie do widoku $Post$;
 \item wyświetlania danego wpisu wraz z~jego komentarzami i~``polubieniami'' - w~tym celu wykonane zostaną odwołania do widoków: $Post$, $Comment$ i~$PostLike$;
 \item wyświetlenia profilu użytkownika wraz z~jego ulubionymi wpisami - w~tym celu wykonane zostanie jedno odwołanie do widoku $User$ i~jedno do widoku $UserLike$.
\end{itemize}

Model zapytań został przedstawiony na rysunku~\ref{fig:single:domain_denormalized}.

\input{figures/implementation_single/domain_denormalized}

Pomiędzy znormalizowanym modelem dziedziny (rysunek~\ref{fig:single:domain_normalized}), a~modelem zdenormalizowanym modelem zapytań wystepują dwie istotne różnice:

\begin{enumerate}
 \item Encja $Like$ została rozbita na dwia widoki: $UserLike$ i~$PostLike$.
 Przechowują one dane inne niż tylko identyfikatory powiązanych encji.
 Umożliwia to wykonywanie stałej (równej $2$) liczby zapytań do bazy danych w~celu wyświetlenia profilu użytkownika wraz z~tytułami lubianych przez niego wpisów (lub wyświetlania wpisu wraz imionami i~nazwiskami użytkowników go lubiących).
 Pozostawienie encji $Like$ w~niezmienionym kształcie skutkowałoby potrzebą wykonania w~tym celu $n + 2$ zapytań, gdzie $n$ to liczba wpisów lubianych przez danego użytkownika (lub liczba użytkowników lubiących dany wpis).
 Brak operacji złączenia w~języku CQL uniemożliwia wydobycie wszystkich potrzebnych danych w~jednym zapytaniu.
 \item Encja $Post$ otrzymała pole $CommentsNumber$.
 Umożliwia to wyświetlenie wpisów wraz z~liczbą ich komentarzy bez potrzeby odwoływania się do widoku $Comment$.
 Używając języka SQL, aby uzyskać te dane przy użyciu pojedynczego zapytania, wystarczyłoby wykorzystać złączenie i~funkcję agregującą $Count$.
 Jednakże język CQL nie umożliwia stworzenia takiego zapytania (a~tym samym wymusza jak najmniejszy koszt zapytania).
\end{enumerate}



%=======
\section{Generowane artefakty} \label{sec:generated_artifacts}
%=======

Artefaktami generowanymi na podstawie opisu dziedziny aplikacji będą:

\begin{itemize}
 \item skrypty DLL definiujące strukturę bazy danych;
 \item klasy wchodzące w~skład modelu zapytań (patrz: sekcja~\ref{sec:cqrs});
 \item klasy reprezentujące zdarzenia zachodzące w~systemie (patrz: sekcja~\ref{sec:event_sourcing});
 \item klasy reprezentujące dane wyświetlane w~interfejsie użytkownika (\emph{view models});
 \item dokumentację systemu w~formacie HTML zawierającą spis widoków należących do modelu zapytań;
 \item pomocnicze skrypty powłoki automatyzujące rutynowe czynności wykonywane przez programistów (patrz: sekcje~\ref{sec:tasks_dupl}, \ref{sec:tasks_scripts}).
\end{itemize}

We wszystkich tych elementach zazwyczaj powielana jest wiedza na temat dziedziny aplikacji.
Elementy mniej narażone na duplikację dziedziny, takie jak klasy realizujące logikę biznesową aplikacji, nie będą generowane przez narzędzie.

Należy zwrócić uwagę na fakt, że klasy reprezentujące poszczególne encje (patrz: rysunek~\ref{fig:single:domain_normalized}) nie muszą być generowane.
Wystarczy, że ich pola występują w~modelu zapytań i~w~klasach zdarzeń.



%=======
\section{Sposób definicji dziedziny}
%=======

Zgodnie z~założeniami dotyczącymi implementacji generatora, wszystkie artefakty wymienione w~sekcji~\ref{sec:generated_artifacts} powinny być generowane na podstawie pojedynczego opisu dziedziny aplikacji.
Podczas implementacji tego aspektu pojawiają się następujące problemy:


\subsection{Czy tworzyć schemat opisu dziedziny?}

Problem ten poruszony został w~sekcji~\ref{sec:core:domain_schema_requirement}.
Stwierdzono, że słusznym wyborem jest stworzenie schematu opisu dziedziny aplikacji.
Pozostaje jednak pytanie, gdzie należy ten schemat zdefiniować i~przechowywać.

Nie ulega wątpliwości, że aby uniknąć duplikacji, schemat opisu dziedziny powinen być zdefiniowany tylko w~jednym miejscu.
Odpowiednim takim miejscem, jako że tam właśnie schemat ten będzie używany, wyjdaje się być klasa należąca do kodu źródłowego generatora aplikacji CQRS.
Gdyby schemat być przechowywany gdzie indziej, odpowiadająca mu klasa i~tak musiałaby być stworzona lub wygenerowana, aby moć zdeserializować dziedzinę do obiektu silnie typizowanego.


\subsection{Schemat opisu dziedziny aplikacji}

Najważniejszym aspektem określenia sposobu definicji dziedziny aplikacji jest określenie schematu tej dziedziny.
Schemat ten powinien pozwalać na zapisanie dowolnej dziedziny w~wygody sposób, tak aby wprowadzanie modyfikacji dziedziny było jak najłatwiejsze.

\subsubsection{Podejście naiwne}

Najprostszym sposobem opisu dziedziny jest jawne wypisanie wszystkich elementów, które powinny być generowane przez generator.
Umożliwi to bardzo łatwą generację artefaktów systemu.
Co więcej, sposób ten jest bardzo elastyczny - elementy dziedziny nie są ze sobą w~żaden sposób powiązane.

Fragment opisu dziedziny przykładowej aplikacji wykorzystujący tę notację przedstawia rysunek~\ref{fig:single:model_verbose}.

\input{figures/implementation_single/model_verbose}

Takie podejście ma jednak istotną wadę - wprowadza szeroko występującą duplikację wiedzy.
Przykładowo, wiedza na temat pól~encji $User$ jest zduplikowana w~widokach $User$ i~$PostLike$.
Oba widoki duplikują informacje o~typach pól tej encji (jak podkreślono w~rozdziale~\ref{chap:duplication}, występowanie nazw pól w~wielu miejscach nie jest duplikacją).
Wprowadza to kilka problemów:

\begin{itemize}
 \item wzbogacenie pojedynczej encji o~nowe pole (lub usunięcie istniejącego pola) wymaga aktualizacji opisu wszystkich widoków i~zdarzeń, w~których to pole będzie występować (lub występuje);
 \item zmiana typu pojedynczego pola wymaga aktualizacji opisu wszystkich widoków i~zdarzeń, w~których to pole występuje;
 \item jeśli opisy poszczególnych widoków i~zdarzeń umieszczone będą w~osobnych plikach, aktualizacje te będą tym bardziej uciążliwe.
\end{itemize}

%\subsubsection{per widok}
%
%Elementy modelu zapytań pojawiają się w~największej liczbie artefaktów systemu - w~skryptach CQL i~klasach modelu zapytań.
%Co więcej, tylko one muszą być dokładnie odwzorowane w~systemie - odpowiadają za przechowywanie danych i~bezpośrednio definiują strukturę bazy danych.
%Dlatego wydaje się, że najlepszym i~najbardziej naturalnym sposobem opisu dziedziny aplikacji jest opisanie jedynie widoków i~użycie tego opisu jako podstawy do %wygenerowania wszystkich artefaktów.
%
%Przykład takiego zapisu został przedstawiony na rysunku~\ref{fig:single:model_perView}.
%
%\input{figures/implementation_single/model_perView}
%
%duplikacje
%trudność wygenerowania modelu komend, i zdarzeń

\subsubsection{Obranie pola jako podstawowego elementu opisu dziedziny}

Aby rozwiązać problem duplikacji, można jako pojedynczy element dziedziny potraktować nie widok, czy zdarzenie, a~pojedyncze pole.
Taki opis zawierałby informację o~każdym z~pól dziedziny systemu wraz z~informacją o~widokach i~zdarzeniach, do których dane pole należy.

Fragment opisu dziedziny przykładowej aplikacji wykorzystujący tę notację przedstawia rysunek~\ref{fig:single:model_perField}.

\input{figures/implementation_single/model_perField}

To rozwiązanie wyeliminowało duplikację z~opisu dziedziny aplikacji, rozwiązując wszystkie problemy powodowane przez podejście opisane wyżej.
Jednakże i~ono posiada pewne wady:

\begin{itemize}
 \item zarządzanie taką listą pól może być utrudnione:
  \begin{itemize}
   \item pola nie są w~żaden sposób pogrupowane,
   \item na liście mogą występować pola o~tej samej nazwie (należące do innych encji);
  \end{itemize}
 \item algorytm wyodrębnienia jednostek generacji na podstawie opisu dziedziny może być skomplikowany;
 \item opis nie zawiera żadnej informacji na temat encji występujących w~systemie (patrz: problemy postawione na końcu sekcji~\ref{sec:cqrs}).
\end{itemize}

\subsubsection{Obranie encji jako podstawowego elementu opisu dziedziny}

Kolejnym podejściem może być potraktowanie encji jako pojedynczego elementu dziedziny - pomimo faktu, że encje nie wystąpią w~żadnym artefakcie systemu.
Taki opis byłby podobny do poprzedniego rozwiązania, jednak pola byłyby pogrupowane według encji, do których należą.

Pełny opis pojedynczej encji wykorzystujący tę notację przedstawia rysunek~\ref{fig:single:model_presentIn}.

\input{figures/implementation_single/model_presentIn}

Rozwiązanie to jest najlepsze spośród omówionych:

\begin{itemize}
 \item nie występuje w~nim duplikacja;
 \item występuje w~nim hierarchiczna organizacja:
 \begin{itemize}
  \item pola są pogrupowane,
  \item występowanie wielu pól o~tej samej nazwie nie jest problemem;
 \end{itemize}
 \item rozwiązuje ono oba problemy postawione na końcu sekcji~\ref{sec:cqrs}:
  \begin{itemize}
   \item wiedza na temat modelu komend (równoważnego z~modelem encji) znalazła się w~opisie dziedziny
   \item na ``pojedynczą, jednoznaczną i~autorytatywną reprezentację wiedzy o~dziedzinie aplikacji'' wybrany został model komend.
  \end{itemize}
\end{itemize}

Jedyną wadą tego podejścia w~stosunku do rozwiązania opisanego jako pierwsze jest to, że algorytm wyodrębnienia jednostek generacji na podstawie takiego opisu dziedziny może być skomplikowany.
Aby skonstruować pojedyczny widok (lub zdarzenie), będzie on musiał odwiedzić opis każdej encji i~przeanalizować zawartość jej listy $PresentInViews$ (lub $PresentInEvents$).
Wada ta jednak nie przesłania zalet tego rozwiązania.


\subsection{Sposób definicji typów pól}

Kolejnym problemem dotyczącym definicji dziedziny aplikacji jest sposób określania typów pól należących do encji.
Bierze się on stąd, że w~różnych językach występują różne typy danych, a~te same typy mogą posiadać różne nazwy.
Przykładowo, typ reprezentujący ciąg znaków w~języku CQL to $text$, a~w~języku C\# - $string$.

\subsubsection{Możliwe rozwiązania}

W~przypadku omawianego generatora, dostępne są cztery możliwości rozwiązania tego problemu:

\begin{itemize}
 \item używanie w~opisie dziedziny jednie typów zaczerpniętych z~języka CQL:
  \begin{itemize}
   \item uprościłoby to generowanie definicji rodzin kolumn bazy danych - typy kolumn mogą zostać pobrane bezpośrednio z~opisu pól encji,
   \item skutkowałoby to wymogiem mapowania typów języka CQL na typy języka C\# podczas generacji klas;
  \end{itemize}
 \item używanie w~opisie dziedziny jednie typów zaczerpniętych z~języka C\#:
  \begin{itemize}
   \item uprościłoby to generowanie klas,
   \item wymagałoby to mapowania typów języka C\# na typy języka CQL podczas generacji definicji rodzin kolumn;
  \end{itemize}
 \item używanie własnych nazw typów - byłoby to podejście uniwersalne, niezależne od języków wykorzystywanych w~systemie, ale wymagające mapowania typów podczas generacji każdego z~artefaktów;
 \item uwzględnianie obu typów w~opisie każdego pola (np. jako osobne wartości: $CQLType$ i~$CShartType$):
  \begin{itemize}
   \item generowanie zarówno klas, jak i~definicji rodzin kolumn byłoby ułatwione,
   \item konieczność definiowania dwóch typów dla każdego pola mogłaby być uciążliwa.
  \end{itemize}
\end{itemize}

\subsubsection{Wybór rozwiązania}

Pomiędzy typami języka C\# i~typami języka CQL występuje korzystna zależność: każdemu typowi języka CQL odpowiada pojedynczy typ języka C\#.
Przykładowo, typom $ascii$, $text$ i~$varchar$ języka CQL odpowiada wspomniany już typ $string$ języka C\#.
Jak widać, zależność ta nie jest symetryczna.

Odpowiednim rozwiązaniem jest więc definiowanie typów pól encji przy użyciu typów języka CQL.
Dlatego w~dotychczas prezentowanych przykładach wszystkie pola encji, widoków i~zdarzeń posiadały typy języka CQL.

Warto podkreślić, że gdyby generowane aplikacje korzystały z~innej bazy danych czy innego języka programowania, lub gdyby korzystały z~więcej niż dwóch języków (np. przechowywały model komend w~bazie danych SQL), to wybrane rozwiązanie mogłoby być niewystarczające.
Można by wtedy skorzystać z~ostatniego z~wymienionych rozwiązań, jednak w~przypadku konieczności definiowania trzech typów dla każdego pola byłoby ono zbyt uciążliwe.
Należałoby wtedy stosować własne nazwy typów (trzecie rozwiązanie) i~zaimplementować mapowanie ich na typy zdefiniowane w~każdym z~używanych języków.


\subsection{organizacja plików wejściowych i wyjściowych}

organizacja plików wejściowych i wyjściowych \ref{sec:core:files_structure}

plik per encja

\ref{fig:single:fileStructure_chosen}
\input{figures/implementation_single/fileStructure_chosen}

gdyby było wiecej encji, pól, widoków, wspieranych opcji: katalog per encja, plik per pole

\ref{fig:single:fileStructure_generic}
\input{figures/implementation_single/fileStructure_generic}


%=======
\section{Podstawowe jednostki generacji}
%=======

\begin{itemize}
 \item entity
 \item event
 \item view
\end{itemize}

I algorytm ich generowania (sklejanie pól encji w widoki)



%=======
\section{Implementacja szablonów generacji}
%=======

Implementacja szablonów

\begin{itemize}
 \item CQL:
  \begin{itemize}
   \item create table
   \item select
  \end{itemize}
 \item C\#:
  \begin{itemize}
   \item entity
   \item event
   \item view
  \end{itemize}
 \item HTML (dokumentancja)
\end{itemize}

\ref{fig:single:template_table}
\input{figures/implementation_single/template_table}

\ref{fig:single:template_class}
\input{figures/implementation_single/template_class}

\ref{fig:single:template_docs}
\input{figures/implementation_single/template_docs}



%=======
\section{Implementacja kolejnych modułów aplikacji}
%=======

\begin{itemize}
 \item CQL (create keyspace, create tables (do pojedynczego skryptu inicjalizującego bazę danych)
 \item DAL (repozytorium bazowe zahardkodowane, konkretnych nie da się wygenerować)
 \item BLL (obsługa zdarzeń zahardkodowana, da się wygenerować Eventy, a EventHandlery?)
 \item WEB (Nancy, da się wygenerować ViewModele, formy)
\end{itemize}



%=======
\section{Abstrachując od konkretnego przykładu}
%=======

Że ten zapis nadaje się nie tylko do CQRS
kroki postępowania:

\begin{itemize}
 \item zdefiniować encje
 \item zdefiniować elementy, gdzie powielana jest wiedza na temat encji (tu: struktura bazy, model zapytań, zdarzenia, view modele)
 \item zdefiniować główne jednostki generacji (niektóre elementy są równoważne) (tu: zdarzenia, widoki)
 \item przypisać pola encji do pól głównych jednostek generacji (jedno pole encji - wiele pól jednostek generacji)
 \item zapisać schemat
\end{itemize}
