\chapter{Implementacja generatora} \label{chap:implementation:single_type}

Generator aplikacji konkretnego typu będzie korzystał z~trzonu narzędzia w~celu wygenerowania części aplikacji opartej o~architekturę CQRS, korzystającej z~wzorca Event Souring i~z~bazy danych Cassandra.
Głównym celem generatora jest wyeliminowanie z~systemu duplikacji opisu dziedziny aplikacji.
Zostanie to osiągnięte przez umieszczenie pełnego opisu dziedziny w~jednym miejscu i na jego podstawie~generowanie innych artefaktów systemu, które duplikowałyby wiedzę na temat dziedziny.

W~celu przestawienia kolejnych kroków implementacji narzędzia, sformułowany zostanie przykład generowanej aplikacji.



%=======
\section{Przykład generowanej aplikacji}
%=======

Przykładowa aplikacja będzie serwisem internetowym, który umożliwia użytkownikom prowadzenie blogów.
Użytkownik serwisu (encja $User$) będzie mógł:

\begin{itemize}
 \item opublikować wpis (encja $Post$) na swoim blogu (zdarzenie $PostPublishedEvent$);
 \item polubić (encja $Like$) wpis innego użytkownika (zdarzenie $PostLikedEvent$);
 \item skomentować (encja $Comment$) wpis innego użytkownika (zdarzenie $PostCommentedEvent$);
 \item skomentować komentarz innego użytkownika (również zdarzenie $PostCommentedEvent$).
\end{itemize}

Dziedzina serwisu została przedstawiona na rysunku~\ref{fig:single:domain_normalized}\footnote{Należy zaznaczyć, że na potrzeby przykładu dziedzina została w~jak największym stopniu uproszczona (np. nie znalazła się w~niej encja $Blog$, która mogłaby przechowywać nazwę, opis i~logo bloga).}.
Jednocześnie reprezentuje ona model komend systemu.
Natomiast zachodzące w~systemie zdarzenia pokazano na rysunku~\ref{fig:single:domain_events}.

\input{figures/implementation_single/domain_normalized}

\input{figures/implementation_single/domain_events}

Na potrzeby architektury CQRS należy także zdefiniować model zapytań.
Elementy wchodzące w~skład tego modelu nazywane będa widokami.
Widoki powinny udostępniać dane zdenormalizowane w~takim stopniu, aby umożliwić jak najefektywniejsze wykonywane najczęstszych zapytań wykonywanych w~systemie~\cite{cassandra_model}.

W~omawianym przykładzie najczęściej wykonywane będa zapytania na potrzeby:

\begin{itemize}
 \item wyświetlania danego bloga, tzn. wszystkich wpisów jego autora wraz z~liczbą ich komentarzy - w~tym celu wykonane zostanie pojedyncze odwołanie do widoku $Post$;
 \item wyświetlania danego wpisu wraz z~jego komentarzami i~``polubieniami'' - w~tym celu wykonane zostaną odwołania do widoków: $Post$, $Comment$ i~$PostLike$;
 \item wyświetlenia profilu użytkownika wraz z~jego ulubionymi wpisami - w~tym celu wykonane zostanie jedno odwołanie do widoku $User$ i~jedno do widoku $UserLike$.
\end{itemize}

Model zapytań został przedstawiony na rysunku~\ref{fig:single:domain_denormalized}.

\input{figures/implementation_single/domain_denormalized}

Pomiędzy znormalizowanym modelem dziedziny (rysunek~\ref{fig:single:domain_normalized}), a~modelem zdenormalizowanym modelem zapytań wystepują dwie istotne różnice:

\begin{enumerate}
 \item Encja $Like$ została rozbita na dwia widoki: $UserLike$ i~$PostLike$.
 Przechowują one dane inne niż tylko identyfikatory powiązanych encji.
 Umożliwia to wykonywanie stałej (równej $2$) liczby zapytań do bazy danych w~celu wyświetlenia profilu użytkownika wraz z~tytułami lubianych przez niego wpisów (lub wyświetlania wpisu wraz imionami i~nazwiskami użytkowników go lubiących).
 Pozostawienie encji $Like$ w~niezmienionym kształcie skutkowałoby potrzebą wykonania w~tym celu $n + 2$ zapytań, gdzie $n$ to liczba wpisów lubianych przez danego użytkownika (lub liczba użytkowników lubiących dany wpis).
 Brak operacji złączenia w~języku CQL uniemożliwia wydobycie wszystkich potrzebnych danych w~jednym zapytaniu.
 \item Widok $Post$ otrzymał pole $CommentsNumber$.
 Umożliwia to wyświetlenie wpisów wraz z~liczbą ich komentarzy bez potrzeby odwoływania się do widoku $Comment$.
 Używając języka SQL, aby uzyskać te dane przy użyciu pojedynczego zapytania, wystarczyłoby wykorzystać złączenie i~funkcję agregującą $Count$.
 Jednakże język CQL nie umożliwia stworzenia takiego zapytania (a~tym samym wymusza jak najmniejszy koszt zapytania).
\end{enumerate}



%=======
\section{Generowane artefakty} \label{sec:generated_artifacts}
%=======

Artefaktami generowanymi na podstawie opisu dziedziny aplikacji będą:

\begin{itemize}
 \item skrypty DLL definiujące strukturę bazy danych;
 \item klasy wchodzące w~skład modelu zapytań (patrz: sekcja~\ref{sec:cqrs});
 \item klasy reprezentujące zdarzenia zachodzące w~systemie (patrz: sekcja~\ref{sec:event_sourcing});
 \item klasy reprezentujące dane wyświetlane w~interfejsie użytkownika (\emph{view models});
 \item dokumentację systemu w~formacie HTML zawierającą spis widoków należących do modelu zapytań;
 \item pomocnicze skrypty powłoki automatyzujące rutynowe czynności wykonywane przez programistów (patrz: sekcje~\ref{sec:tasks_dupl}, \ref{sec:tasks_scripts}).
\end{itemize}

We wszystkich tych elementach zazwyczaj powielana jest wiedza na temat dziedziny aplikacji.
Elementy mniej narażone na duplikację dziedziny, takie jak klasy realizujące logikę biznesową aplikacji, nie będą generowane przez narzędzie.

Należy zwrócić uwagę na fakt, że klasy reprezentujące poszczególne encje (patrz: rysunek~\ref{fig:single:domain_normalized}) nie muszą być generowane.
Wystarczy, że ich pola występują w~modelu zapytań i~w~klasach zdarzeń.



%=======
\section{Sposób definicji dziedziny}
%=======

Zgodnie z~założeniami dotyczącymi implementacji generatora, wszystkie artefakty wymienione w~sekcji~\ref{sec:generated_artifacts} powinny być generowane na podstawie pojedynczego opisu dziedziny aplikacji.
Podczas implementacji tego aspektu pojawiają się następujące problemy:


\subsection{Czy tworzyć schemat opisu dziedziny?}

Problem ten poruszony został w~sekcji~\ref{sec:core:domain_schema_requirement}.
Stwierdzono, że słusznym wyborem jest stworzenie schematu opisu dziedziny aplikacji.
Pozostaje jednak pytanie, gdzie należy ten schemat zdefiniować i~przechowywać.

Nie ulega wątpliwości, że aby uniknąć duplikacji, schemat opisu dziedziny powinen być zdefiniowany tylko w~jednym miejscu.
Odpowiednim takim miejscem, jako że tam właśnie schemat ten będzie używany, wyjdaje się być klasa należąca do kodu źródłowego generatora aplikacji CQRS.
Gdyby schemat być przechowywany gdzie indziej, odpowiadająca mu klasa i~tak musiałaby być stworzona lub wygenerowana, aby moć zdeserializować dziedzinę do obiektu silnie typizowanego.


\subsection{Schemat opisu dziedziny aplikacji}

Najważniejszym aspektem określenia sposobu definicji dziedziny aplikacji jest określenie schematu tej dziedziny.
Schemat ten powinien pozwalać na zapisanie dowolnej dziedziny w~wygody sposób, tak aby wprowadzanie modyfikacji dziedziny było jak najłatwiejsze.

\subsubsection{wszystko}

Najprostszym sposobem opisu dziedziny jest jawne wypisanie wszystkich elementów, które powinny być generowane przez generator.
Umożliwi to bardzo łatwą generację artefaktów systemu.
Co więcej, sposób ten jest bardzo elastyczny - elementy dziedziny nie są ze sobą w~żaden sposób powiązane.

Fragment opisu dziedziny przykładowej aplikacji wykorzystujący tę notację przedstawia rysunek~\ref{fig:single:model_verbose}.

\input{figures/implementation_single/model_verbose}

Takie podejście ma jednak istotną wadę - wprowadza szeroko występującą duplikację wiedzy.
Przykładowo, wiedza na temat pól~encji $User$ jest zduplikowana w~widokach $User$ i~$PostLike$.
Oba widoki duplikują informacje o~typach pól tej encji (jak podkreślono w~rozdziale~\ref{chap:duplication}, występowanie nazw pól w~wielu miejscach nie jest duplikacją).
Wprowadza to kilka problemów:

\begin{itemize}
 \item wzbogacenie pojedynczej encji o~nowe pole (lub usunięcie istniejącego pola) wymaga aktualizacji opisu wszystkich widoków i~zdarzeń, w~których to pole będzie występować (lub występuje);
 \item zmiana typu pojedynczego pola wymaga aktualizacji opisu wszystkich widoków i~zdarzeń, w~których to pole występuje;
 \item jeśli opisy poszczególnych widoków i~zdarzeń umieszczone będą w~osobnych plikach, aktualizacje te będą tym bardziej uciążliwe.
\end{itemize}

%\subsubsection{per widok}
%
%Elementy modelu zapytań pojawiają się w~największej liczbie artefaktów systemu - w~skryptach CQL i~klasach modelu zapytań.
%Co więcej, tylko one muszą być dokładnie odwzorowane w~systemie - odpowiadają za przechowywanie danych i~bezpośrednio definiują strukturę bazy danych.
%Dlatego wydaje się, że najlepszym i~najbardziej naturalnym sposobem opisu dziedziny aplikacji jest opisanie jedynie widoków i~użycie tego opisu jako podstawy do %wygenerowania wszystkich artefaktów.
%
%Przykład takiego zapisu został przedstawiony na rysunku~\ref{fig:single:model_perView}.
%
%\input{figures/implementation_single/model_perView}
%
%duplikacje
%trudność wygenerowania modelu komend, i zdarzeń

\subsubsection{per pole}

Aby rozwiązać problem duplikacji, można jako pojedynczy element dziedziny potraktować nie encję, widok, czy zdarzenie, a~pojedyncze pole.
Taki opis zawierałby informację o~każdym z~pól dziedziny systemu wraz z~informacją o~widokach i~zdarzeniach, do których dane pole należy.

Fragment opisu dziedziny przykładowej aplikacji wykorzystujący tę notację przedstawia rysunek~\ref{fig:single:model_perField}.

\input{figures/implementation_single/model_perField}

To rozwiązanie wyeliminowało duplikację z~opisu dziedziny aplikacji, rozwiązując wszystkie problemy powodowane przez podejście opisane wyżej.
Jednakże i~ono posiada pewne wady:

\begin{itemize}
 \item zarządzanie taką listą pól może być utrudnione - pola nie są w~żaden sposób pogrupowane;
 \item 
\end{itemize}

\subsubsection{per encja}

PresentIn
brak duplikacji
encje generują się same, generacja widoków i zdarzeń wymaga trochę pracy, ale jest ok

\ref{fig:single:model_presentIn}
\input{figures/implementation_single/model_presentIn}

Wybór 3 rozwiązuje oba problemy postawione na końcu sekcji~\ref{sec:cqrs}:

\begin{itemize}
 \item costam
 \item costam
\end{itemize}


\subsection{które typy umieścić w definicji?}

które typy umieścić w definicji? CQLowe, .NETowe, czy własne? (nie ma potrzeby własnych, bo trzeba by robić dwie mapy; lepiej CQLowe bo jeden .NETowy mapuje się na wiele CQLowych) (że będzie potrzebna TypesMap.GetDotNetType)


\subsection{organizacja plików wejściowych i wyjściowych}

organizacja plików wejściowych i wyjściowych \ref{sec:core:files_structure}



%=======
\section{Podstawowe jednostki generacji}
%=======

\begin{itemize}
 \item entity
 \item event
 \item view
\end{itemize}

I algorytm ich generowania (sklejanie pól encji w widoki)



%=======
\section{Implementacja szablonów generacji}
%=======

Implementacja szablonów

\begin{itemize}
 \item CQL:
  \begin{itemize}
   \item create table
   \item select
  \end{itemize}
 \item C\#:
  \begin{itemize}
   \item entity
   \item event
   \item view
  \end{itemize}
 \item HTML (dokumentancja)
\end{itemize}

\ref{fig:single:template_table}
\input{figures/implementation_single/template_table}

\ref{fig:single:template_class}
\input{figures/implementation_single/template_class}

\ref{fig:single:template_docs}
\input{figures/implementation_single/template_docs}



%=======
\section{Implementacja kolejnych modułów aplikacji}
%=======

\begin{itemize}
 \item CQL (create keyspace, create tables (do pojedynczego skryptu inicjalizującego bazę danych)
 \item DAL (repozytorium bazowe zahardkodowane, konkretnych nie da się wygenerować)
 \item BLL (obsługa zdarzeń zahardkodowana, da się wygenerować Eventy, a EventHandlery?)
 \item WEB (Nancy, da się wygenerować ViewModele, formy)
\end{itemize}



%=======
\section{Abstrachując od konkretnego przykładu}
%=======

Że ten zapis nadaje się nie tylko do CQRS
kroki postępowania:

\begin{itemize}
 \item zdefiniować encje
 \item zdefiniować elementy, gdzie powielana jest wiedza na temat encji (tu: struktura bazy, model zapytań, zdarzenia, view modele)
 \item zdefiniować główne jednostki generacji (niektóre elementy są równoważne) (tu: zdarzenia, widoki)
 \item przypisać pola encji do pól głównych jednostek generacji (jedno pole encji - wiele pól jednostek generacji)
 \item zapisać schemat
\end{itemize}
