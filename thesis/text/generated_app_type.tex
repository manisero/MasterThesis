\chapter{Sprecyzowanie typu generowanych aplikacji} \label{chap:generated_app_type}

Po zebraniu założeń dotyczących rdzenia narzędzia generującego aplikacje, nadszedł czas na wybór typu aplikacji, które będą generowane przez narzędzie.



%=======
\section{Wybór typu aplikacji}
%=======

Narzędzie powinno generować taki typ aplikacji, aby można było w~pełni zbadać jego użyteczność i~ocenić, na ile eliminuje ono duplikację.
Aby było to możliwe, narzędzie powinno generować aplikacje, w~których występuje dużo potencjalnych miejsc występowania duplikacji.

Wymaganie to spełniają aplikacje o~architekturze wielowarstwowej (ang. \emph{multi-tier architecture, n-tier architecture}~\cite{ntier}).


\subsection{Architektura wielowarstwowa}

Architektura wielowarstwowa to taka, w~której ogólne obszary przetwarzania danych w~aplikacji są fizycznie rozdzielone pomiędzy osobne komponenty.
Współpraca pomiędzy tymi komponentami jest zorganizowana w~taki sposób, że komponent $A$ może korzystać z~funkcjonalności komponentu $B$ tylko wtedy, gdy komponent $B$ należy do warstwy logicznie umiejscowionej nie wyżej niż warstwa, do której należy komponent $A$.

Przykładem, a jednocześnie najpopularniejszą realizacją tej architektury jest architektura trójwarstwowa (ang. \emph{three-tier architecture}), która wprowadza podział aplikcji na trzy warstwy:

\begin{enumerate}
 \item Warstwa prezentacji (ang. \emph{Presentation Layer}) - odpowiada za komunikację z~użytkownikiem aplikacji (np. poprzez interfejs graficzny) lub innymi systemami (np. poprzez usługi sieciowe); jest to warstwa logicznie najwyższa;
 \item Warstwa logiki biznesowej (ang. \emph{Business Logic Layer, BLL}) - odpowiada za przetwarzanie danych zgodnie z~wymaganiami funkcjonalnymi aplikacji;
 \item Warstwa dostępu do danych (ang. \emph{Data Access Layer, DAL}) - udostępnia mechanizmy odczytu i~zapisu danych składowanych przez aplikację (np. w~pamięci lub w~bazie danych); jest to warstwa logicznie najniższa.
\end{enumerate}

Współpracę pomiędzy warstwami architektury trójwarstwowej przedstawia diagram zamieszczony na rysunku~\ref{fig:three_tier}.

\input{figures/generated_app_type/three_tier}

W~takiej architekturze elementy dziedziny aplikacji często mają swoje odwzorowanie w~każdej z~warstw, na przykład:

\begin{itemize}
 \item jako obiekty modelu w~warstwie dostępu do danych;
 \item jako obiekty biznesowe (ang. \emph{business object})~\cite{business_object} w~warstwie logiki biznesowej;
 \item jako modele widoków (ang. \emph{view model})~\cite{view_model} interfejsu użytkownika lub obiekty tranportu danych (ang. \emph{Data Transfer Object, DTO})~\cite{dto} usług sieciowych w~warstwie prezentacji.
\end{itemize}

To sprawia, że aplikacja o~architekturze wielowarstwowej jest narażona na powszechne występowanie duplikacji wiedzy na temat dziedziny aplikacji, a~tym samym dobrze nadaje się jako typ aplikacji generowanych przez narzędzie.



%=======
\section{CQRS}
%=======

Przypadkiem szczególnym architektury wielowarstwowej jest architektura CQRS (\emph{Command Query Responsibility Segregation})~\cite{cqrs}.
Zakłada ona podział wszystkich działań w~aplikacji na dwa rodzaje:

\begin{itemize}
 \item zapytanie (ang. \emph{query}) - działanie polegające na pobraniu danych z~bazy danych (lub innego źródła danych);
 \item komenda (ang. \emph{command}) - działanie polegające na modyfikacji danych w~bazie danych.
\end{itemize}

Działania te w~architekturze CQRS są rozłączne.
Ich wykonywaniem zajmują się dwa osobne modele danych aplikacji:

\begin{itemize}
 \item model zapytań (ang. \emph{Query Model}) - model przeznaczony do odczytu danych;
 \item model komend (ang. \emph{Command Model}) - model przeznaczony do modyfikacji danych.
\end{itemize}

Modele te mogą być całkowicie rozłączne lub częściowo na siebie zachodzić.
Koncepcyjny schemat tej architektury przedstawia rysunek~\ref{fig:cqrs}.

\input{figures/generated_app_type/cqrs}

Podział odpowiedzialności pomiędzy komponenty przedstawia się następująco:

\begin{itemize}
 \item model zapytań zajmuje się odczytywaniem danych z~bazy danych;
 \item odpowiedzialnością modelu komend jest realizacja logiki biznesowej aplikacji, w~tym weryfikacja poprawności danych, aktualizacja danych w~bazie danych itd.;
 \item warstwa prezentacji (\emph{UI}):
  \begin{itemize}
   \item wyświetla dane pobrane z~modelu zapytań za pośrednictwem interfejsów (\emph{Service Interfaces}),
   \item przekazuje - w~postaci komend - akcje wykonywane przez użytkownika do modelu komend.
  \end{itemize}
\end{itemize}

Wprowadzenie podziału pomiędzy zapytanie i~komendę niesie ze sobą dwie ważne zalety:

\begin{itemize}
 \item skomplikowana dziedzina aplikacji może być podzielona na dwie prostsze dziedziny, co ułatwia jej zrozumiene i~operowanie na niej;
 \item zapytania i~komendy mogą być wykonywane równolegle, co poprawia wydajność aplikacji;
 \item zapytania są wykonywane na specjalnie przygotowanych dla nich danych (np. zmaterializowanych widokach bazy danych), co ma bardzo pozytywny wpływ na ich wydajność.
\end{itemize}

W~parze z~zaletami idą jednak wady:

\begin{itemize}
 \item synchronizacja obu modeli w~przypadku, gdy korzystają one z~osobnych źródeł danych może być kłopotliwa; problem ten nie występuje na przykład wtedy, gdy model komend operuje na tabelach bazy danych, a~model zapytań - na zmaterializowanych widokach, których źródłem danych są te tabele (synchronizacja modeli odbywa się wtedy automatycznie po stronie bazy danych);
 \item aby każde zapytanie mogło być obsłużone jak najszybciej, model jest w~dużym stopniu zdenormalizowany.
\end{itemize}

Konsekwencją drugiej wady jest to, że w~modelu zapytań masowo występuje duplikacja elementów dziedziny aplikacji.
Jest to dobry powód do tego, aby generator generował aplikacje oparte właśnie o~architekturę CQRS.
Dodatkowo, wybór tej architektury stworzy okazję do przyjrzenia się innym problemom związanym z~zastosowaniem architektury CQRS.
Te problemy to:

\begin{enumerate}
 \item Model komend i model zapytań częściowo na siebie zachodzą lub nawet model zapytań w~całości zawiera model komend - rodzi to dwa pytania:
 \begin{itemize}
  \item jak w~tej sytuacji uniknąć duplikacji wiedzy na temat dziedziny aplikacji?
  \item który model wybrać na “pojedynczą, jednoznaczną i~autorytatywną” (patrz: Zasada ``DRY'' w~rozdziale~\ref{chap:duplication}) reprezentację wiedzy o~dziedzinie aplikacji?
 \end{itemize}
 \item Model komend może nie być nigdzie fizycznie przechowywany - komendy mogą bezpośrednio aktualizować zdenormalizowaną strukturę tabel bazy danych.
 Gdzie w~takim przypadku należy umieścić wiedzę na temat encji należących do dziedziny apliacji?
 Model zapytań nie zawiera przecież encji dziedziny, a~tylko widoki na te encje.
\end{enumerate}

Architektura CQRS często idzie w~parze z~wykorzystaniem wzorca Event Sourcing i~baz danych typu NoSQL.
Zagadnienia te zostaną opisane w~kolejnych sekcjach.



%=======
\section{Event sourcing}
%=======

\begin{itemize}
 \item opisać Event Sourcing
\end{itemize}



%=======
\section{NoSQL}
%=======

\begin{itemize}
 \item opisać NoSQL
  \begin{itemize}
   \item opisać rodzaje baz NoSQL
   \item wybrać bazę NoSQL i dlaczego Cassandra
  \end{itemize}
\end{itemize}



%=======
\section{Cassandra}
%=======

opisać Cassandrę
