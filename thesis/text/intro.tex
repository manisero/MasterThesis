\chapter{Wstęp} \label{chap:intro}

\begin{itemize}

 \item Wstęp
 
 \item Duplikacja
  \begin{itemize}
   \item Rodzaje duplikacji
   \item Skutki wystąpienia duplikacji
   \item Możliwe rozwiązania
  \end{itemize}
 
 \item Sprecyzowanie problemu
  \begin{itemize}
   \item że rozwiązanie będzie oparte o generację
   \item że zajmę się głównie dziedziną aplikacji
  \end{itemize}
 
 \item Generacja
  \begin{itemize}
   \item kiedy to się opłaca, a kiedy może powodować problemy
   \item przykłady konkretnych dużych generatorów
   \item wniosek: żaden generator nie będzie jednocześnie bogaty w funkcjonalności i dobry dla każdego typu aplikacji
   \item zatem: rozwięzanie podzielę na dwie części
    \begin{itemize}
     \item trzon narzędzia do generacji
     \item generator aplikacji jednego typu
    \end{itemize}
  \end{itemize}
 
 \item Trzon narzędzia do generacji:
  \begin{itemize}
   \item jakiej organizacji plików źródłowych oczekuje generator
    \begin{itemize}
     \item organizajca powinna być właściwie dowolna
     \item plików źródłowych może być wiele
     \item powinien być wspierany scenariusz, gdzie jeden plik docelowy jest generowany na podstawie kilku źródłowych i odwrotnie
    \end{itemize}
   \item kroki generacji:
    \begin{itemize}
     \item wczytanie definicji dziedziny aplikacji
     \item zdeserializowanie jej
     \item wyodrębnienie konkretnych jednostek generacji (np. encji) (tego core nie zrobi)
     \item użycie zdefiniowanych (nie przez core) szablonów do wygenerowania plików na podstawie jednostek generacji
    \end{itemize}
   \item sposób zdefiniowania dziedziny aplikacji
    \begin{itemize}
     \item np. UML czy EMF (?) nie nadają się zbytnio bo działają na encjach, a chodzi o pojedyncze pola
     \item podkreślić, że podstawową jednostką nie jest encja, tylko pole
     \item format powinien być zupełnie dowolny
     \item domyślnie będzie JSON, ale można to łatwo podmienić
    \end{itemize}
   \item czy wymagać stworzenia schematu definicji dziedziny aplikacji?
    \begin{itemize}
     \item są dwie opcje:
      \begin{itemize}
       \item (no schema) definicję dziedziny deserializować do dynamic, szablonom przekazywać dynamic (jest dowolność, ale nie wyłapie się błędów podczas deserializacji)
       \item definicję dziedziny deserializować do konkretnego typu, szablonom przekazywać konkretne typy
      \end{itemize}
     \item druga opcja wydaje się lepsza (opis dziedziny powinien być spójny)
     \item ale mechanizm będzie generyczny, decyzja będzie należała do konkretnego generatora
    \end{itemize}
   \item Wybór silnika do generacji kodu (templating engine)
    \begin{itemize}
     \item opisać dostępne w .NET
     \item dlaczego t4? - np. razor nie, bo razora tez mozemy chciec generowac - generowanie razora razorem mogloby byc utrudnione
    \end{itemize}
  \end{itemize}

  \item Założenia co do generatora aplikacji pojedynczego typu
   \begin{itemize}
    \item wybrać typ aplikacji
    \item dlaczego CQRS
     \item bo zdenormalizowana dziedzina
     \item gdzie w CQRS zdefiniowana jest dziedzina (encje) aplikacji? Model do odczytywania nie zawiera przecież encji, a tylko widoki.
     \item model "read" i model "write" częściowo na siebie zachodzą (lub nawet "read" zawiera "write"). Jak uniknąć duplikacji metadanych?
    \item opisać CQRS
    \item że często idzie w parze z Event Sourcing
    \item opisać Event Sourcing
    \item że całość dobrze idzie w parze z NoSQL
    \item opisać NoSQL
     \begin{itemize}
      \item opisać rodzaje baz NoSQL
      \item wybrać bazę NoSQL i dlaczego Cassandra
      \item opisać Cassandrę
     \end{itemize}
   \end{itemize}
  
  \item Implementacja generatora aplikacji pojedynczego typu
   \begin{itemize}
    \item Ogólnie nie chodzi o to, żeby w ogóle nie pisać nazw klas / właściwości - tylko o to, żeby nie trzeba było pamiętać o wszystkich miejscach, gdzie dana encja jest używana.
    \item czy w ogóle generować schemat bazy danych (no schema) (?)
    \item wybrać sposób definicji dedziny
     \item że będzie schema
     \item ale że schema powinna być w jednym miejsu - będzie jako klasa w kodzie
     \item wybór formatu
      \item uml, emf się nie nadają - operują na encjach, a nie na polach
      \item xml albo json, bez różnicy - czytelniejszy i bardziej intuicyjny wydaje się JSON (xml ma atrybuty i węzły zagnieżdzone - nie wiadomo czego użyć)
     \item zdefiniowanie schematu opisu dziedziny na potrzeby CQRS
      \begin{itemize}
       \item PresentIn
      \end{itemize}
    \item Wybrór klienta Cassandry (?)
    \item Sformułowanie przykładu aplikacji
    \item Zapisanie schemy w JSONie
    \item Implementacja szablonów
    \item Implementacja kolejnych modułów aplikacji
     \begin{itemize}
      \item DAL (repozytorium bazowe zahardkodowane, konkretnych nie da się wygenerować)
      \item BLL (obsługa zdarzeń zahardkodowana, da się wygenerować EventHandlery)
      \item WEB (Nancy, da się wygenerować ViewModele, formy)
     \end{itemize}
   \end{itemize}
  
  \item Ocena rozwiązania
   \begin{itemize}
    \item Co dało się wygenerować, a co nie
    \item Jakiej duplikacji udało się uniknąć
    \item jak łatwo wprowadza się zmiany w aplikacji
    \item ile pracy wymagałoby dodanie nowej funkcjonalności (API, eksport) - przykład?
    \item jaką inną aplikację można wygenerować (przykład)
   \end{itemize}
  
  \item Wnioski
  
  \item Koniec

\end{itemize}

