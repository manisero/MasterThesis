\chapter{Wstęp} \label{chap:intro}

\begin{itemize}

 \item Wstęp
 
 \item Duplikacja
  \begin{itemize}
   \item Rodzaje duplikacji
   \item Skutki wystąpienia duplikacji
   \item Możliwe rozwiązania
  \end{itemize}
 
 \item Sprecyzowanie problemu
  \begin{itemize}
   \item że rozwiązanie będzie oparte o generację
   \item że zajmę się głównie dziedziną aplikacji
  \end{itemize}
 
 \item Generacja
  \begin{itemize}
   \item kiedy to się opłaca, a kiedy może powodować problemy
   \item przykłady konkretnych dużych generatorów
   \item wniosek: żaden generator nie będzie jednocześnie bogaty w funkcjonalności i dobry dla każdego typu aplikacji
   \item zatem: rozwięzanie podzielę na dwie części
    \begin{itemize}
     \item trzon narzędzia do generacji
     \item generator aplikacji jednego typu
    \end{itemize}
  \end{itemize}

  \item Założenia co do generatora aplikacji pojedynczego typu
   \begin{itemize}
    \item wybrać typ aplikacji
    \item dlaczego CQRS
     \item bo zdenormalizowana dziedzina
     \item gdzie w CQRS zdefiniowana jest dziedzina (encje) aplikacji? Model do odczytywania nie zawiera przecież encji, a tylko widoki.
     \item model "read" i model "write" częściowo na siebie zachodzą (lub nawet "read" zawiera "write"). Jak uniknąć duplikacji metadanych?
    \item opisać CQRS
    \item że często idzie w parze z Event Sourcing
    \item opisać Event Sourcing
    \item że całość dobrze idzie w parze z NoSQL
    \item opisać NoSQL
     \begin{itemize}
      \item opisać rodzaje baz NoSQL
      \item wybrać bazę NoSQL i dlaczego Cassandra
      \item opisać Cassandrę
     \end{itemize}
   \end{itemize}
  
  \item Implementacja generatora aplikacji pojedynczego typu
   \begin{itemize}
    \item Ogólnie nie chodzi o to, żeby w ogóle nie pisać nazw klas / właściwości - tylko o to, żeby nie trzeba było pamiętać o wszystkich miejscach, gdzie dana encja jest używana.
    \item czy w ogóle generować schemat bazy danych (no schema) (?)
    \item wybrać sposób definicji dedziny
     \item że będzie schema
     \item ale że schema powinna być w jednym miejsu - będzie jako klasa w kodzie
     \item wybór formatu
      \item uml, emf się nie nadają - operują na encjach, a nie na polach
      \item xml albo json, bez różnicy - czytelniejszy i bardziej intuicyjny wydaje się JSON (xml ma atrybuty i węzły zagnieżdzone - nie wiadomo czego użyć)
     \item zdefiniowanie schematu opisu dziedziny na potrzeby CQRS
      \begin{itemize}
       \item PresentIn
      \end{itemize}
    \item Wybrór klienta Cassandry (?)
    \item Sformułowanie przykładu aplikacji
    \item Zapisanie schemy w JSONie
    \item Implementacja szablonów
    \item Implementacja kolejnych modułów aplikacji
     \begin{itemize}
      \item DAL (repozytorium bazowe zahardkodowane, konkretnych nie da się wygenerować)
      \item BLL (obsługa zdarzeń zahardkodowana, da się wygenerować EventHandlery)
      \item WEB (Nancy, da się wygenerować ViewModele, formy)
     \end{itemize}
   \end{itemize}
  
  \item Ocena rozwiązania
   \begin{itemize}
    \item Co dało się wygenerować, a co nie
    \item Jakiej duplikacji udało się uniknąć
    \item jak łatwo wprowadza się zmiany w aplikacji
    \item ile pracy wymagałoby dodanie nowej funkcjonalności (API, eksport) - przykład?
    \item jaką inną aplikację można wygenerować (przykład)
   \end{itemize}
  
  \item Wnioski
  
  \item Koniec

\end{itemize}

