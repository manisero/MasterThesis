\chapter{Duplikacja} \label{chap:duplication}

Zasada ``DRY'' (ang. \emph{``Don't Repeat Yourself''}), sformułowana przez Andrew Hunt'a i~David'a Thomas'a, mówi: ``Każda porcja wiedzy powinna mieć pojedynczą, jednoznaczną, autorytatywną reprezentację w~systemie''~\cite{prag:prog}.
Poprawne jej stosowanie skutkuje osiągnięciem stanu, w~którym pojedyncza zmiana zachowania systemu wymaga modyfikacji tylko jednego fragmentu reprezentacji wiedzy.
Należy podkreślić, że autorzy tej zasady przez ``reprezentację wiedzy'' rozumieją nie tylko kod źródłowy tworzony przez programistów systemu.
Zaliczają do niej również dokumentację systemu, schemat bazy danych przez niego używanej i~inne artefakty powstające w~procesie wytwarzania oprogramowania (takie jak np. scenariusze testów akceptacyjnych), a~nawet czynności wykonywane rutynowo przez programistów.

Celem stosowania tej zasady ``DRY'' jest unikanie duplikacji wiedzy zawartej w~systemie.
Duplikacją określa się fakt występowania w~systemie dwóch reprezentacji tej samej porcji wiedzy.
Należy wyjaśnić, że wielokrotne występowanie nazw klas lub zmiennych (bądź innych identyfikatorów) w~kodzie programu nie jest duplikacją - identyfikatory są jedynie odnośnikami do wiedzy reprezentowanej przez artefakty, które identyfikują.



%=======
\section{Rodzaje duplikacji}
%=======

Wyróżnia się cztery rodzaje duplikacji ze względu na przyczynę jej powstania~\cite{prag:prog}:

\begin{itemize}
 \item duplikacja wymuszona (ang. \emph{imposed duplication}) - pojawia się gdy programista świadomie duplikuje kod aplikacji uznając, że w~danej sytuacji jest to nie do uniknięcia;
 \item duplikacja niezamierzona (ang. \emph{inadvertent duplication}) - występuje, gry programista nie jest świadomy, że doprowadza do duplikacji;
 \item duplikacja niecierpliwa (ang. \emph{impatient duplication}) - jest wynikiem niedbalstwa programisty; ma miejsce w sytuacji, gdy programista świadomie wybierze rozwiązanie najprostsze w danej sytuacji;
 \item duplikacja pomiędzy programistami (ang. \emph{interdeveloper duplication}) - pojawia się, gdy kilku programistów tworzących tę samą aplikację wzajemnie duplikuje tworzony kod.
\end{itemize}

Duplikacja może występować w~różnych postaciach:


\subsection{Duplikacja czynności wykonywanych przez programistów}

Do rutynowych czynności wykonywanych podczas pracy programisty należą wszelkiego rodzaju aktualizacje: schematu bazy danych rezydującej na maszynie programisty czy wersji tworzonego oprogramowania zainstalowanej w~środowisku testowym lub produkcyjnym.

Czynności te zwykle składają się z~kilku kroków. Przykładowo, na aktualizację bazy danych może składać się:

\begin{enumerate}
 \item Usunięcie istniejącej bazy.
 \item Stworzenie nowej bazy.
 \item Zainicjalizowanie schematu nowej bazy przy pomocy skryptu DLL.
 \item Wypełnienie nowej bazy danymi przy pomocy skryptu DML.
\end{enumerate}

Jeśli wszystkie z~tych kroków wykonywane są ręcznie, mamy do czynienia z~duplikacją - każdy programista w~zespole, zamiast tylko odwoływać się do wiedzy o~tym, jak zaktualizować bazę danych, musi posiadać tę więdzę i~wcielać ją w~życie krok po kroku.


\subsection{Duplikacja kodu źródłowego aplikacji}

Programistom wielokrotnie zdarza się spowodować duplikację w~kodzie źródłowym tworzonych programów.
Powielone fragmenty kodu są zazwyczaj niewielkie, a podzielić je można na następujące kategorie~\cite{soft:sol:dupl}:

\begin{itemize}
 \item duplikacja wyrażeń (ang. \emph{literal duplication}) - najprostszy rodzaj duplikacji; obejmuje fragmenty kodu, których treść jest identyczna bądź różni się jedynie typami danych, na których te fragmenty operują (przykład: dwie identyczne metody umiejscowione w~różnych modułach systemu); 
 \item duplikacja strukturalna (ang. \emph{structural duplication}) - obejmuje fragmenty kodu, które mają ten sam schemat działania, ale różnią się pojedynczymi instrukcjami (przykład: dwie pętle iterurąjce po tej samej kolekcji z~tym samym warunkiem stopu, ale wykonujące różne operacje na elementach kolekcji);
 \item duplikacja czasowa (ang. \emph{temporal duplication}) - określa fragment kodu, który jest niepotrzebnie wykonynway wiele razy (przykład: zliczenie elementów kolekcji podczas każdego sprawdzenia warunku stopu pętli iterurąjcej po tej kolekcji);
 \item duplikacja intencji (ang. \emph{duplication of intent}) - występuje, gdy dwóch programistów umieści w~różnych modułach aplikacji dwa fragmenty, których wynik działania (ale niekoniecznie treść) jest identyczny.
\end{itemize}


\subsection{Duplikacja opisu dziedziny aplikacji}

W~każdej aplikacji obiektowej korzystającej z bazy danych występuje duplikacja opisu dziedziny aplikacji.
Występuje ona w~co najmniej dwóch miejsach:

\begin{enumerate}
 \item schemacie bazy danych (DDL),
 \item definicjach klas w~kodzie źródłowym aplikacji.
\end{enumerate}

Kolejnym typowym miejscem, w~którym umieszcza się informacje o~dziedzinie aplikacji jest jej dokumentacja.

W~miarę jak rozrasta się projekt informatyczny, pojawia się tendencja do duplikowania fragmentów dziedziny poruszanego przez niego problemu.
Duplikacja ta rozprzestrzenia się pomiędzy modułami aplikacji, których zadaniem obróbka tych samych danych, ale w~różny sposób.
Przykładowo, aplikacja może udostępniać przechowywane dane na następujące sposoby:

\begin{itemize}
 \item wyświetlać je na stronie WWW,
 \item wystawiać jako API,
 \item eksportować do arkusza kalkulacyjnego.
\end{itemize}

Jeśli moduły te posiadają osobne implementacje dziedziny aplikacji, to każda zmiana dziedziny wymaga zmodyfikowania implementacji dziedziny w~każdym z~modułów - co wiąże się z~dużymi kosztami.

Z~drugiej strony, identyczność zestawu danych udostępnianego przez różne moduły może nie być pożądana.
Przykładowo, na stronie WWW wyświetlane mogą być jedynie podstawowe dane danej encji, podczas gdy pełne dane dostępne są po wyeksportowaniu arkusza kalkulacyjnego.
Takie wymaganie wymusza duplikację części dziedziny aplikacji pomiędzy różnymi implementacjami tej dziedziny.


\emph{TODO: Sformułować konkretny przykład aplikacji.}



%=======
\section{Skutki występowania duplikacji}
%=======

Pojawinie się duplikacji w~systemie ma zazwyczaj szkodliwe skutki.
Rozprzestrzenia się ona tym szybciej, a wyrządzane szkody są tym dotkliwsze, im więszy jest rozmiar systemu.

Najbardziej oczywistym skutkiem występowania duplikacji jest wydłużenie się czasu poświęcanego przez programistów na nieskomplikowane lub powtarzalne zadania.
Przykładowo, nieznajomość kodu współdzielonego przez wszystkie moduły systemu (tzw. rdzenia, ang. \emph{core}) powoduje, że programiści niepotrzebnie spędzają czas na implementowaniu podstawowych funcji, które są już dostępne w rdzeniu systemu.
Innym przykładem może być praktyka ręcznego wykonywania czynności, które mogą być łatwo zautomatyzowane.
Procedura aktualizacji schematu bazy danych, na którą składa się wykonanie kilku skryptów DDL zajmnie dużo mniej czasu, jeśli wykona ją skrypt.
Wrzucenie nowej wersji systemu na staging lub produkcje nie musi wiązać się z~ręcznym wrzucaniem plików na ftp zdalnej maszyny - może dziać się automatycznie (ref continous delivery).

\emph{TODO: Nie podawać tu rozwiązań, skupić się na szkodach.}

Po drugie, zmiana zachowania systemu wymaga modyfikacji wielu modułów systemu.
Jeśli nie jest nigdzie zapisane, jakich - trzeba wszystkie miejsca zlokalizować ręcznie.
Najbardziej jest to widoczne przy naprawie błędów: jeśli występuje duplikacja kodu, to programista naprawiający błąd powinien mieć swiadomość, że poprawiany przez niego fragment kodu może być powielony w~wielu miejscach w~systemie.
Wszystkie te miejsca musi zlokalizować i~poprawić~\cite{repetition}.

Po trzecie, rozmiar systemu
- czytelność kodu (jest rozwleczony)
- rozmiar plików

Po czwarte, pojawienie się jednej dupliakcji to przyzwolenie na wprowadzenie innej



%=======
\section{Rozwiązanie: skrypty na wszystkie czynności}
%=======

na update bazy, na deploy na stg / prod


%=======
\section{Rozwiązanie: generyczna implementacja}
%=======

\subsection{Refleksja}
\emph{TODO: Czy generatory to jedyne rozwiązanie? Duplikacji pozwala też uniknąć refleksja.}


\subsection{Serializacja (do JSONA)}
TODO


\subsection{Inne generyczne rozwiązania}
TODO

Zauważmy jednak, że przedstawione propozycje rozwiązują jedynie problem duplikacji w logice biznesowej, podczas gdy najwięcej rodzajów duplikacji dotyczy dziedziny aplikacji.



%=======
\section{Rozwiązanie: użycie licznych generatorów}
%=======

\subsection{Generator code-first / database-first}

Rozwiązaniem problemu może być osiągnięcie implementacji, w~której pełna dziedzina aplikacji definiowana jest w jednym miejscu, a~jej implementacje są generowane automatycznie w~odpowiednich modułach.
Taka sytuacja sprawia, że duplikacja pomiędzy modułami przestaje być problemem - aby wprowadzić zmiany we wszystkich implementacjach, wystarczy wprowadzic pojedynczą modyfikację w~definicji dziedziny aplikacji.

Najprostszym przykładem realizującym to rozwiązanie jest użycie generatora definicji klas na podstawie schematu bazy danych (tzw. podejście database-first) lub generatora schematu bazy danych na podstawie definicji klas (tzw. podejście code-first).
Przykładami takich generatorów są:

\begin{itemize}
 \item Hibernate,
 \item EntityFramework,
 \item LinqToSQL.
\end{itemize}

\emph{TODO: Wymienić więcej, dla różnych technolgii, dać przypisy.}

Jednakże takie generatory eliminują tylko jeden rodzaj duplikacji, wymieniony na początku rozdziału.


\subsection{Generator dokumentacji}

Duplikacji w~dokumentacji aplikacji można uniknąć poprzez zastosowanie narzędzi generujących tę dokumentację na podstawie kodu źródłowego aplikacji.
Narzędzia takie pozwalają na wygenerowanie dokumentacji w~kilku formatach, takich jak PDF czy HTML.
Ich przykłady to:

\begin{itemize}
 \item JavaDoc,
 \item ...
\end{itemize}

\emph{TODO: Wymienić więcej, dla różnych technolgii, dać przypisy.}

W~przypadku tych narzędzi występuje ten sam problem, co w~przypadku generatorów schematu bazy danych lub definicji klas - eliminują one tylko jeden rodzaj duplikacji.


\subsection{Inne generatory}

Aby uniknąć pozostałych rodzajów duplikacji:

\begin{itemize}
 \item duplikowania nazw i~typów kolumn tabel w~definicjach widoków bazy danych,
 \item duplikowania nazw i~typów pól klas pomiędzy implementacjami dziedziny aplikacji w~różnych jej modułach,
\end{itemize}

należałoby skorzystać z~kolejnych generatorów.

Warto zauważyć, że różne typy generatorów za źródło danych obierają sobie różne definicje dziedziny: np. generator database-first bazuje na języku DDL, a~generator dokumentacji - na kodzie źródłowym aplikacji.
Używanie wielu różnych generatorów usuwających pojedyncze rozdzaje duplikacji w końcu doprowadziłoby do powstania ``łańcucha'' generatów, w~którym wynik działania jedngo generatora byłby źródłem danych dla innego.
Takie rozwiązanie może być bardzo trudne w~utrzymaniu.



%=======
\section{Rozwiązanie: jeden generator wszystkiego}
%=======

Odpowiednim rozwiązaniem wydaje się być zastosowanie pojedynczego generatora potrafiącego wygenerować wszystkie potrzebne artefakty.
Powstanie takiego generatora dającego się zastosować w~każdym projekcie jest jednak bardzo mało prawdopodobne:

\begin{itemize}
 \item każdy projekt ma inne wymagania odnośnie wygenerowanych artefaktów,
 \item prawdopodobne nie istnieje format, który pozwalałby zdefiniować każdą dziedzinę w~najlepszy (najbardziej naturalny) dla niej sposób.
\end{itemize}



Przedstawione rozwiązania eliminują tylko pojedyncze rodzaje duplikacji.
Rozwiązanie potencjalnie optymalne to mix wszystkiego po trochu.

\emph{TODO: Czemu skupiam się na dziedzinie aplikacji - wydaje się bardziej kosztowna niż duplikacja czynności, a łatwiejsza do usunięcia niż duplikacja kodu.}

W dalszej części pracy najwięcej zostanie poświęcone rodzajom duplikacji, których usunięcie nie wymaga ciągłej dyscypliny od programistów (bo na to każde rozwiązanie może być zawodne).
