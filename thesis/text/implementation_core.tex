\chapter{Implementacja trzonu narzędzia} \label{chap:implementation:core}

Zanim przystąpimy do prac nad generatorem aplikacji konkretnego typu, zajmijmy się samym procesem generacji artefaktów systemu, nazwanym tutaj ``trzonem'' narzędzia.



%=======
\section{Podstawowe założenia dotyczące trzonu narzędzia} \label{sec:core:basic_requirements}
%=======

O ile elastyczność generatora konkretnego typu aplikacji może być ograniczona, o~tyle trzon powinien być na tyle uniwersalny, by mógł być użyty w~celu wygenerowania wielu rodzajów plików tekstowych, w~tym kodu źródłowego w~dowolnym języku, skryptów DLL, skryptów powłoki, dokumentancji w~formacie HTML lub XML itd.
Pliki te powinny być generowane w~ten sam sposób (np. na podstawie szablonów napisanych w~jednym języki, takim jak xslt), tak aby programista korzystający z~narzędzia nie musiał poznawać całej gamy języków lub narzędzi używanych do tworzenia szablonów generacji.
Pożądaną funkcjonalnością jest możliwość łatwiej wymiany domyślnie użwanego rodzaju szablonów na inny, tak aby programista korzystający z~narzędzia mógł w~łatwy sposób użyć w~nim szablonów stworzonych w~języku, ktory zna.
Co więcej, trzon narzędzia nie pownien narzucać sposobu formatowania danych wejściowych (w~tym przypadku - opisu dziedziny aplikaji).

Dla wygody autora narzędzia zakłada się, że zarówno trzon narzędzia jak i~generator konkretnego typu aplikacji zostanie stworzony w~technolgii .NET Framework



%=======
\section{Kroki generacji}
%=======

Generacja odbbywać się będzie w~natępujących krokach:


\subsection{Wczytanie definicji dziedziny aplikacji}

Generator na wejściu przyjmował będzie ścieżkę do pliku lub katalogu źródłowego (patrz: sekcja~\ref{sec:core:files_structure}.
Każdego plik zostanie odwiedzony przez generator, a~jego treść zostanie zdeserializowana do obiektu odpowiadającej mu klasy.


\subsection{Zdeserializowanie definicji dziedziny aplkacji}

Jak wymieniono w~założeniach dotyczących trzonu generatora (patrz:~\ref{sec:core:basic_requirements}, format opisu dziedziny aplikacji nie będzie narzucony z~góry.
Każdy plik źródłowy może być zapisany w~innym formacie (np. JSON lub XML).
Domyślnie wspierany będzie jeden format~\ref{sec:core:domain_definition}, a~użytkownik generatora będzie mógł dla każdego pliku źródłowego określić wybrany i~dostarczony przez siebie sposób deserializacji.

Zdeserializowany obiekt dziedziny może posłużyć jako wskazanie na kolejne pliki reprezentujące elementy dziedziny.
Przykładem obrazującym potrzebę takiego działania może być sytuacja, w~której plik zawiera ogólne informacje na temat encji, pliku w~podkatalogu sąsiadującym z~tym plikiem zawierają definicje poszczególnych pól danej encji (patrz: sekcja~\ref{sec:core:files_structure:many_folders}).
Wtedy wczytanie i~deserializacja pól encji odbędzie się dopiero po zdeserializowaniu opisu samej encji i~na tej podstawie określeniu, który katalog zawiera kolejne pliki opisujące elementy do niej należące. 


\subsection{Wyodrębnienie jednostek generacji}

Po uzyskaniu kompletnego obiektu - lub kolekcji obiektów - opisującego dziedzinę aplikacji, tzn. po zdeserializowaniu wszystkich plików zawierających dziedzinę aplikacji, generator będzie musiał przygotować kolejne obiekty (tutaj: jednostki generacji), które będą podstawą do wygenerowania plików wynikowych.
Jednostką generacji może być na przykład pojedyncza encja dziedziny aplikacji.

Aby zachować elastyczność, krok ten będzie musiał być zaimplementowany po stronie użytkownika generatora, tzn. generatora aplikacji konkretnego typu.
Umożliwi to obsłużenie scenariusza, w~którym na podstawie pojedynczego elementy opisu dziedziny aplikacji generowanych będzie wiele różnych plików (np. definicja tabeli bazy danych, definicja klasy w~kodzie źródłowym aplkacji i~kod HTML będący częścią dokumentancji systemu).
Odpowiedzialność wyekstrahowania jednostek generacji z~pełnego opisu dziedziny zostanie zrzucona na użytkownika generatora dlatego, że trzon generatora nie jest w~stanie go zautomatyzować bez utraty elastyczności.
Aby jednak obsłużyć najprostsze scenariusze, pominięcie implementacji tego kroku w~aplikacji będącej użytkownikiem generatora zaskutkuje potraktowaniem głównego obieku dziedziny (lub kolekcji obiektów) jako jednostki generacji (lub osobnych jednostek generacji).

Uzyskane jednostki generacji bezpośrednio posłużą do wygenerowania plików wynikowych - pojedyncza jednostka odpowiadać będzie pojedynczemu plikowi wynikowemu.


\subsection{Użycie szablonów do wygenerowania plików}

Ostatnim krokiem generacji będzie użycie jednostek generacji do wygenerowania plików wynikowych.
Domyślny mechanizm generacji pliku wynikowego oparty będzie o~wykorzystanie silnika generacji plików na postawie szablonu generacji (patrz: sekcja~\ref{sec:core:templating_engine}).

Trzon generatora przekaże daną jednostkę generacji odpowiedniemu szablonowi, a~wygenerowana treśc zostanie umieszczona w~odpowiednim pliku.
Zadaniem użytkownika generatora będzie dostarczenie zarówno szablonu generacji, jak i~ściezki, pod którą ma się znaleźć wygenerowany plik.

Aby zachować elastyczność, wykorzystywany silnik, jak również cały mechanizm generacji będzie mógł zostać wymieniony na inny przez użytkonika generatora.



%=======
\section{Organizacja plików wejściowych i~wyjściowych} \label{sec:core:files_structure}
%=======

Pierszą decyzją, którą należy podjąć w~trakcie implementacji, jest organizacja i~format plików źródłowych, na których pracował będzie trzon narzędzia, także organizacja plików, które będzie w~stanie wygenerować.
Jak wspomniano wyżej, od trzonu oczekuje się jak największej elastyczności - dlatego trzon powinien wspierać kilka scenariuszy.
Za przykład niech posłuży internetowy portal informacyjny.


\subsection{Pojedynczy plik źródłowy}

W~tym scenariuszu całość dziedziny aplikacji (lub innych informacji o~systmie) zawarta jest pojedynczym pliku.
Przykładem zastosowania może pojedynczy skrypt SQL zawierający schemat bazy danych używanej przez aplkację.
Taki plik, oprócz swojego standardowego przeznaczenia, tj. konfigurowania bazy danych, pełniłby rolę źródła generatora \emph{Code First}.
Na jego podstawie generowane byłyby pliki zawierające defnijcje klas będących częścią implementacji modelu dziedziny w~aplikacji.

Rysunek~\ref{fig:implementation_core:singleSourceFile} obrazuje przykład.

\input{figures/implementation_core/singleSourceFile}


\subsection{Pojedynczy katalog z~wieloma plikami źródłowymi}

Kontynuując przykład, w~miarę upływu czasu portal może rozrosnąć się na tyle, że wprowadzi możliwość prowadzenia blogów przez jego użytkowników.
Wtedy może wystąpić potrzeba podzielenia schematu bazy danych na kilka plików - np. według nazw schematów (ang. \emph{scheme})), w~których znajdują się poszczególne tabele.
Wszystkie te pliki w~dalszym ciągu byłyby źródłem dla generatora, a~wynikowe klasy mogłyby być umieszczone w~osobnych katalogach (podzielonych według nazw schematow, w~których znajdują się odpowiadające im tabele).

Rysunek~\ref{fig:implementation_core:multipleSourceFiles} obrazuje przykład.

\input{figures/implementation_core/multipleSourceFiles}


\subsection{Drzewo katalogów z~wielona plikami źródłowymi} \label{sec:core:files_structure:many_folders}

W~dłuższej perspektywie, w~opisywanym przykładzie może pojawić się potrzeba wprowadzenia podkatalogów dla poszczególnych schematów.
Pojedynczy podkatalog zawierałby osobne pliki zawierające definicje tabel, widoków i~procedur składowanych obecnych w~bazie danych.
Trzon narzędzia generującego powinien być w~stanie dotrzeć do wszystkich tych plików.

Rysunek~\ref{fig:implementation_core:multipleFolders} obrazuje przykład.

\input{figures/implementation_core/multipleFolders}

Innym przykładem wykorzystującym ten scenariusz scenariuszem jest sytuacja, w~której pojedynczy plik wynikowy generowany jest z~wielu plików źródłowych.
Przykladem może być zorganizowanie opisu dziedziny aplikacji w~taki sposób, że informacje na temat każdego pola każdej encji umieszczone są w~osobnym pliku.
Rysunek~\ref{fig:implementation_core:multipleFolders_multipleInputFiles} obrazuje przykład.

\input{figures/implementation_core/multipleFolders_multipleInputFiles}

Taka organizacja może mieć zastosowanie w~przypadku, gdy w~systemiie w~wielu miejscach występują jedynie fragmenty encji (np. w~widokach bazy danych).
Wtedy każde pole może wymagać skonfigurowania dla niego miejsc, w~których występuje.



%=======
\section{Sposób zdefiniowania dziedziny aplikacji} \label{sec:core:domain_definition}
%=======

\begin{itemize}
 \item np. UML czy EMF (?) nie nadają się zbytnio bo działają na encjach, a chodzi o pojedyncze pola
 \item podkreślić, że podstawową jednostką nie jest encja, tylko pole
 \item format powinien być zupełnie dowolny
 \item domyślnie będzie JSON, ale można to łatwo podmienić
\end{itemize}



%=======
\section{Czy wymagać stworzenia schematu definicji dziedziny aplikacji?} \label{sec:core:domain_schema_requirement}
%=======

\begin{itemize}
 \item są dwie opcje:
  \begin{itemize}
   \item (no schema) definicję dziedziny deserializować do dynamic, szablonom przekazywać dynamic (jest dowolność, ale nie wyłapie się błędów podczas deserializacji)
   \item definicję dziedziny deserializować do konkretnego typu, szablonom przekazywać konkretne typy
  \end{itemize}
 \item druga opcja wydaje się lepsza (opis dziedziny powinien być spójny)
 \item ale mechanizm będzie generyczny, decyzja będzie należała do konkretnego generatora
\end{itemize}



%=======
\section{Wybór silnika do generacji kodu (templating engine)} \label{sec:core:templating_engine}
%=======

\begin{itemize}
 \item opisać dostępne w .NET
 \item dlaczego t4? - np. razor nie, bo razora tez mozemy chciec generowac - generowanie razora razorem mogloby byc utrudnione
\end{itemize}
