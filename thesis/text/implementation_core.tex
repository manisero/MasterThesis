\chapter{Implementacja trzonu narzędzia} \label{chap:implementation:core}

\begin{itemize}
 \item +jakiej organizacji plików źródłowych oczekuje generator
 \item kroki generacji:
  \begin{itemize}
   \item wczytanie definicji dziedziny aplikacji
   \item zdeserializowanie jej
   \item wyodrębnienie konkretnych jednostek generacji (np. encji) (tego core nie zrobi)
   \item użycie zdefiniowanych (nie przez core) szablonów do wygenerowania plików na podstawie jednostek generacji
  \end{itemize}
 \item sposób zdefiniowania dziedziny aplikacji
  \begin{itemize}
   \item np. UML czy EMF (?) nie nadają się zbytnio bo działają na encjach, a chodzi o pojedyncze pola
   \item podkreślić, że podstawową jednostką nie jest encja, tylko pole
   \item format powinien być zupełnie dowolny
   \item domyślnie będzie JSON, ale można to łatwo podmienić
  \end{itemize}
 \item czy wymagać stworzenia schematu definicji dziedziny aplikacji?
  \begin{itemize}
   \item są dwie opcje:
    \begin{itemize}
     \item (no schema) definicję dziedziny deserializować do dynamic, szablonom przekazywać dynamic (jest dowolność, ale nie wyłapie się błędów podczas deserializacji)
     \item definicję dziedziny deserializować do konkretnego typu, szablonom przekazywać konkretne typy
    \end{itemize}
   \item druga opcja wydaje się lepsza (opis dziedziny powinien być spójny)
   \item ale mechanizm będzie generyczny, decyzja będzie należała do konkretnego generatora
  \end{itemize}
 \item Wybór silnika do generacji kodu (templating engine)
  \begin{itemize}
   \item opisać dostępne w .NET
   \item dlaczego t4? - np. razor nie, bo razora tez mozemy chciec generowac - generowanie razora razorem mogloby byc utrudnione
  \end{itemize}
\end{itemize}

Zanim przystąpimy do prac nad generatorem aplikacji konkretnego typu, zajmijmy się samym procesem generacji artefaktów systemu, nazwanym tutaj ``trzonem'' narzędzia.



%=======
\section{Podstawowe założenia dotyczące trzonu narzędzia}
%=======

O ile elastyczność generatora konkretnego typu aplikacji może być ograniczona, o~tyle trzon powinien być na tyle uniwersalny, by mógł być użyty w~celu wygenerowania wielu rodzajów plików tekstowych, w~tym kodu źródłowego w~dowolnym języku, skryptów DLL, skryptów powłoki, dokumentancji w~formacie HTML lub XML itd.
Pliki te powinny być generowane w~ten sam sposób (np. na podstawie szablonów napisanych w~jednym języki, takim jak xslt), tak aby programista korzystający z~narzędzia nie musiał poznawać całej gamy języków lub narzędzi używanych do tworzenia szablonów generacji.
Pożądaną funkcjonalnością jest możliwość łatwiej wymiany domyślnie użwanego rodzaju szablonów na inny, tak aby programista korzystający z~narzędzia mógł w~łatwy sposób użyć w~nim szablonów stworzonych w~języku, ktory zna.
Co więcej, trzon narzędzia nie pownien narzucać sposobu formatowania danych wejściowych (w~tym przypadku - opisu dziedziny aplikaji).

Dla wygody autora narzędzia zakłada się, że zarówno trzon narzędzia jak i~generator konkretnego typu aplikacji zostanie stworzony w~technolgii .NET Framework



%=======
\section{Organizacja plików wejściowych i~wyjściowych}
%=======

Pierszą decyzją, którą należy podjąć w~trakcie implementacji, jest organizacja i~format plików źródłowych, na których pracował będzie trzon narzędzia, także organizacja plików, które będzie w~stanie wygenerować.
Jak wspomniano wyżej, od trzonu oczekuje się jak największej elastyczności - dlatego trzon powinien wspierać kilka scenariuszy.
Za przykład niech posłuży internetowy portal informacyjny.


\subsection{Pojedynczy plik źródłowy}

W~tym scenariuszu całość dziedziny aplikacji (lub innych informacji o~systmie) zawarta jest pojedynczym pliku.
Przykładem zastosowania może pojedynczy skrypt SQL zawierający schemat bazy danych używanej przez aplkację.
Taki plik, oprócz swojego standardowego przeznaczenia, tj. konfigurowania bazy danych, pełniłby rolę źródła generatora \emph{Code First}.
Na jego podstawie generowane byłyby pliki zawierające defnijcje klas będących częścią implementacji modelu dziedziny w~aplikacji.

Rysunek~\ref{fig:implementation_core:singleSourceFile} obrazuje przykład.

\input{figures/implementation_core/singleSourceFile}


\subsection{Pojedynczy katalog z~wieloma plikami źródłowymi}

Kontynuując przykład, w~miarę upływu czasu portal może rozrosnąć się na tyle, że wprowadzi możliwość prowadzenia blogów przez jego użytkowników.
Wtedy może wystąpić potrzeba podzielenia schematu bazy danych na kilka plików - np. według nazw schematów (ang. \emph{scheme})), w~których znajdują się poszczególne tabele.
Wszystkie te pliki w~dalszym ciągu byłyby źródłem dla generatora, a~wynikowe klasy mogłyby być umieszczone w~osobnych katalogach (podzielonych według nazw schematow, w~których znajdują się odpowiadające im tabele).

Rysunek~\ref{fig:implementation_core:multipleSourceFiles} obrazuje przykład.

\input{figures/implementation_core/multipleSourceFiles}


\subsection{Drzewo katalogów z~wielona plikami źródłowymi}

W~dłuższej perspektywie, w~opisywanym przykładzie może pojawić się potrzeba wprowadzenia podkatalogów dla poszczególnych schematów.
Pojedynczy podkatalog zawierałby osobne pliki zawierające definicje tabel, widoków i~procedur składowanych obecnych w~bazie danych.
Trzon narzędzia generującego powinien być w~stanie dotrzeć do wszystkich tych plików.

Rysunek~\ref{fig:implementation_core:multipleFolders} obrazuje przykład.

\input{figures/implementation_core/multipleFolders}

Innym przykładem wykorzystującym ten scenariusz scenariuszem jest sytuacja, w~której pojedynczy plik wynikowy generowany jest z~wielu plików źródłowych.
Przykladem może być zorganizowanie opisu dziedziny aplikacji w~taki sposób, że informacje na temat każdego pola każdej encji umieszczone są w~osobnym pliku.
Rysunek~\ref{fig:implementation_core:multipleFolders_multipleInputFiles} obrazuje przykład.

\input{figures/implementation_core/multipleFolders_multipleInputFiles}

Taka organizacja może mieć zastosowanie w~przypadku, gdy w~systemiie w~wielu miejscach występują jedynie fragmenty encji (np. w~widokach bazy danych).
Wtedy każde pole może wymagać skonfigurowania dla niego miejsc, w~których występuje.



%=======
\section{Kroki generacji}
%=======

\subsection{Wczytanie definicji dziedziny aplikacji}


\subsection{Zdeserializowanie definicji dziedziny aplkacji}


\subsection{Wyodrębnienie jednostek generacji}

- jednostek generacji - np. encji

- tego core nie zrobi


\subsection{Użycie szablonów do wygenerowania plików}

- szablonów zdefiniowanych nie przez core
- wygenerowania na podstawie jednostek generacji
