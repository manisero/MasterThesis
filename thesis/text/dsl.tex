\chapter{DSL}

- że ma być czytelne dla człowieka
- że jak najbardziej business-friendly
- że wynik taki sam jak dla opisu w poprzednim rozdziale
- różnica tylko w opisie dziedziny i algorytmie wyodrębniania jednostek generacji (szablony i wszystko inne takie samo)

%=======
\section{Składnia}
%=======

Składnie języków DSL są opracowywane w~taki sposób, aby języki te były czytelne dla osób niebędących programistami - np. menadżerów czy klientów.
Składnia języka opracowanego na potrzeby niniejszej pracy jest dostosowana do dziedziny przykładowej aplikacji, a~przy tym jest czytelna i~zrozumiała.

W~kolejnych sekcjach przestawiono zasady definicji encji, zdarzeń i~widoków systemu.


\subsection{Encje i~ich pola}

Zasady opisu encji są następujące:

\begin{itemize}
 \item nazwy encji poprzedzone są znakiem małpy:
  \begin{itemize}
   \item przykład: \verb|@User|;
  \end{itemize}
  
 \item nazwy pól wchodzących w~skład klucza encji wymienione są w~jej identyfikatorze, w~nawiasach okrągłych bezpośrednio po nazwie encji:
  \begin{itemize}
   \item przykład: \verb|@User(UserName)|,
   \item nazwy pól wchodzących w~skład klucza złożonego oddzielone są przecinkami (bez spacji),
   \item klucz encji wystarczy zdefiniować w~jednym (dowolnym) wystąpieniu jej identyfikatora,
   \item w~opisie dziedziny nie mogą wystąpić dwie różne definicje klucza tej samej encji,
   \item definicja klucza encji musi wystąpić przy co najmniej jednym wystąpieniu jej identyfikatora;
  \end{itemize}
 
 \item pola należące do encji występują po jej identyfikatorze, oddzielone od niego znakiem dwukropka:
  \begin{itemize}
   \item przykład: \verb|@User:FirstName|;
  \end{itemize}
  
 \item typ pola podany jest nawiasach kwadratowych bezpośrednio po nazwie pola
  \begin{itemize}
   \item przykłady: \verb|@Post(PostID[id])|, \verb|@Post:CommentsNumber[int]|,
   \item typ pola wystarczy zdefiniować przy jednym (dowolnym) wystąpieniu jego nazwy,
   \item w~opisie dziedziny nie mogą wystąpić dwie różne definicje typu tego samego pola,
   \item polom, których definicja typu nie występuje ani razu, nadawany jest typ $text$;
  \end{itemize}
 
 \item relację ``wiele do jednego'' pomiędzy encjami oznacza się znakiem dwukropka, oddzielającym identyfikatory tych encji:
  \begin{itemize}
   \item przykład: \verb|@Post:@User:FirstName|,
   \item znaczenie: \emph{z~jedną instancją encji} \verb|@User| \emph{powiązanych jest wiele instancji encji} \verb|@Post|;
  \end{itemize}
 
 \item relację ``jeden do wielu'' pomiędzy encjami oznacza się dwoma znakami dwukropka, oddzielającymi identyfikatory tych encji:
  \begin{itemize}
   \item przykład: \verb|@Post::@Comment:Content|,
   \item znaczenie: \emph{z~jedną instancją encji} \verb|@Post| \emph{powiązanych jest wiele instancji encji} \verb|@Comment|.
  \end{itemize}
\end{itemize}

Składnia opisu encji została sformułowana tak, aby była jak najbardziej przystęna dla osoby niebędącej programistą.
Po pierwsze, występują w~niej tylko dwa znaki specjalne: małpa i~dwukropek.
Nie występują też w~niej żadne słowa kluczowe.

Po drugie, informację o~kluczu danej encji czy typie danego pola wystarczy podać raz.
Co więcej, można to zrobić przy dowolnym wystąpieniu danego identyfikatora.
Pozwala to użytkownikowi na samodzielny wybór części opisu dziedziny, w~których zawrze te informacje - mogą to być na przykład najważniejze według niego widoki i~zdarzenia systemu.

Po trzecie, typy pól encji nie są związane z~żadnym konkretnym językiem~(patrz:~\ref{sec:field_type_definition}).
Zostały dobrane tak, aby osoba nieznająca języków programowania nie miała problemów z~ich nadawaniem.
Zestaw typów pól encji obsługiwany przez język to:

\begin{itemize}
 \item $text$ - ciąg znaków; jego odpowiednikiem w~CQL jest również $text$, a~w~C\# - $string$;
 \item $int$ - liczba całkowita; typ ten nazywa się tak samo zarówno w~CQL, jak i~w~C\#;
 \item $id$ - unikalny identyfikator; jego odpowiednikiem w~CQL jest $timeuuid$, a~w~C\# - $Guid$.
\end{itemize}

Jak widać, zestaw typów jest niewielki i~przystępny.
Konieczność używania nazw typów zaczerpniętych z~języka CQL lub C\# mogłaby zniechęcić docelowego użytkownika - w~szczególności typy oznaczające unikalny identyfikator mogłyby być trudne do zrozumienia i~zapamiętania.

Użycie nazw typów niezależnych od języków, w~których tworzony jest system, ma jeszcze jedną zaletę z~punktu widzenia użytkownika, który nie jest programistą.
Możliwe jest używanie tego samego zestawu typów dla wielu systemów, tworzonych w~różnych technologiach.
Użytkownik może pamiętać tylko jeden zestaw typów i~nie musi znać technologii, w~której tworzony jest system, którego dziedzinę definiuje.


\subsection{Zdarzenia}

Składnia opisu zdarzeń jest następująca:

\begin{itemize}
 \item sekcja definicji zdarzeń następuje w~opisie dziedziny po linii o~treści ``\verb|Events:|'';
 \item definicja pojedynczego zdarzenia składa się z dwóch części:
  \begin{itemize}
   \item nazwy zdarzenia,
   \item opisu zdarzenia, zawierającego identyfikatory i~pola encji wchodzących w~jego skład;
  \end{itemize}
 \item przykład: \verb|Post published: @Post with @Post:Content can be published.|;
 \item definicje kolejnych zdarzeń są od siebie oddzielone pustymi liniami.
\end{itemize}

Pojedyncza definicja zdarzenia jednoznacznie określa pojedyncze zdarzenie wchodzące w~skład modelu komend systemu.


\subsection{Widoki}

Składnia opisu widoków jest następująca:

\begin{itemize}
 \item sekcja definicji widoków następuje w~opisie dziedziny po linii o~treści ``\verb|Views:|'';
 \item definicja widoku to opis zawierający identyfikatory i~pola encji w~nim występujących;
 \item przykład: \verb|I can display @Post with @Post:Title and @Post:Content.|;
 \item definicje kolejnych widoków są od siebie oddzielone pustymi liniami.
\end{itemize}

Pojedyncza definicja widoku nie określa jednoznacznie pojedynczego widoku wchodzącego w~skład modelu zapytań systemu.
Określa natomiast treść wyświetlaną na pojedynczym ekranie aplikajcji, co z~biznesowego punktu widzenia jest bardziej intuicyjne.

Model zapytań będzie więc generowany stopniowo na podstawie analizy wszystkich definicji widoków zawartych w~opisie dziedziny.
Po analizie pojedynczej definicji widoku będzie następować aktualizacja całej definicji modelu zapytań.

Należy zwrócić uwagę na fakt, że opisy zdarzeń i~widoków przypominają zdania w~języku naturalnym.
Znacząco zwiększa to przystępność języka dla osób niebędących programistami.


%=======
\section{Przykład}
%=======

Przykład opisu dziedziny zapisanego przy użyciu prezentowanego języka przedstawia rysunek~\ref{fig:dsl:model_dsl}.
Zawiera on opis wszystkich funkcjonalności przykładowego systemu, tzn. opis wszystkich zdarzeń i~widoków opisanych w~sekcji patrz:~\ref{sec:sample_app}.

\input{figures/dsl/model_dsl}

Należy zwrócić uwagę na czytelność i~zwięzłość tego opisu.
Żaden z~przedstawionych wcześniej sposobów opisu dziedziny nie pozwalał na zaprezentowanie pełnego opisu na jednej stronie, podczas gdy powyższy opis mieści się na jednej stronie mimo zawarcia w~nim pustych linii i~słów w~języku naturalnym.



%=======
\section{Algorytm wyodrębnienia jednostek generacji z opisu dziedziny}
%=======

Algorytm wyodrębnienia jednostek generacji z opisu dziedziny, podobnie do algorytmu przedstawionego w~poprzednim rozdziale, analizuje opis dziedziny i~zwraca listy jednostek generacji (widoków i~zdarzeń) występujących w~systemie.


\subsection{Pojęcie relacji}

W~algorytmie wprowadzono pojęcie relacji.
Reprezentuje ono fakt występowania pomiędzy dwiema encjami relacji ``jeden do wielu'' lub ``wiele do jednego''.
Pojedyncza relacja przechowuje nazwę widoku nadrzędnego, nazwę widoku podrzędnego i~nazwy pól widoku nadrzędnego, do których odwołuje się widok podrzędny.

Jeśli w~zbiorze relacji znajdą się relacje: ``jeden $X$ do wielu $Y$'' i~``wiele $X$ do jednego $Y$'', to uznaje się, że pomiędzy relacjami $X$ i~$Y$ występuje relacja ``wiele do wielu''.

Zbiór zidentyfikowanych relacji jest analizowany w~ostatnim kroku algorytmu, a~przebieg i~cel tej analizy opisano w~sekcji~\ref{sec:relation_processing}.


\subsection{Kroki algorytmu}

Algorytm wyodrębnienia jednostek generacji z opisu dziedziny przebiega następująco:

\begin{enumerate}
 \item Stwórz pustą listę widoków $V$, pustą listę relacji $R$ i~pustą listę zdarzeń $E$.
 \item Dla każdej definicji widoku zawartej w~sekcji definicji widoków:
  \begin{enumerate}
   \item Dla każdego identyfikatora $id$ encji występującego w~definicji widoku wykonaj \emph{Algorytm przetwarzania identyfikatora encji} (patrz:~\ref{sec:entity_id_processing}).
  \end{enumerate}
 
 \item Dla każdej definicji zdarzenia zawartej w~sekcji definicji zdarzeń:
  \begin{enumerate}
   \item Stwórz zdarzenie $e$ o~nazwie utworzonej na podstawie nazwy podanej w~defnicji zdarzenia (np. ``PostPublishedEvent'' na podstawie nazwy ``Post published'').
   \item Dla każdego identyfikatora $id$ encji występującego w~opisie zdarzenia:
    \begin{enumerate}
     \item Wykonaj \emph{Algorytm przetwarzania identyfikatora encji}, uzyskując widok $v$ i~pole $f$.
     \item Dodaj $f$ do pól zdarzenia $e$.
    \end{enumerate}
   \item Dodaj $e$ do $E$.
  \end{enumerate}
  
 \item Wykonaj \emph{Algorytm przetwarzania relacji} (patrz:~\ref{sec:relation_processing}).

 \item Zwróć $V$ i~$E$.
\end{enumerate}


\subsection{Algorytm przetwarzania identyfikatora encji} \label{sec:entity_id_processing}

Algorytm przetwarzania identyfikatora encji analizuje pojedynczy identyfikator encji w~celu utworzenia na jego podstawie nowego widoku lub dodania nowych pól do już istniejących widoków.
Przetwarza on także klucze widoków i~typy pól encji.
Wynikiem jego działania jest widok i~pole uzyskane na podstawie identyfikatora encji.

Algorytm przebiega następująco (w~poniższym opsie pominięto obsługę błędów składniowych):

\begin{enumerate}
 \item Jako parametry wejściowe przyjmij identyfikator encji $id$, listę dotychczas utworzonych widoków $V$ i~listę dotychczas utworzonych relacji $R$.
 \item Jeśli $V$ nie zawiera widoku o~nazwie podanej w~$id$, stwórz taki widok $v$ i~dodaj go do $V$; w przeciwnym razie pobierz widok $v$ z~$V$.
 \item Jeśli $id$ zawiera definicję klucza widoku:
  \begin{enumerate}
   \item Stwórz pustą listę pól $F$.
   \item Dla każdego identyfikatora pola $id_f$ podanego w~definicji klucza widoku:
    \begin{enumerate}
     \item Wykonaj \emph{Algorytm przetwarzania identyfikatora pola} (patrz:~\ref{sec:field_id_processing}), uzyskując pole $f$.
     \item Dodaj $f$ do $F$.
    \end{enumerate}
   \item Ustaw $F$ jako klucz $v$.
  \end{enumerate}
 \item Jeśli $id$ zawiera definicję pola widoku:
  \begin{enumerate}
   \item Wykonaj \emph{Algorytm przetwarzania identyfikatora pola}, uzyskując pole $f$.
   \item Zwróć $v$ i~$f$.
  \end{enumerate}
 \item W~przeciwnym razie, jeśli $id$ zawiera definicję relacji (``wiele do jednego'' lub ``jeden do wielu''):
  \begin{enumerate}
   \item Rekurencyjnie wykonaj algorytm dla identyfikatora powiązaniej encji (wraz z~identyfikatorem jej klucza i~pola, jeśli zostały podane), uzyskując widok $v'$ i~pole $f'$.
   \item Jeśli $R$ nie zawiera relacji odpowiedniego typu pomiędzy $v$ i~$v'$, stwórz taką relację $r$ i~dodaj ją do $R$; w przeciwnym razie pobierz relację $r$ z~$R$.
   \item Dodaj $f'$ do $r$.
   \item Zwróć $v$ i~$f'$.
  \end{enumerate}
 \item Zwróć $v$.
\end{enumerate}


\subsection{Algorytm przetwarzania identyfikatora pola} \label{sec:field_id_processing}

Algorytm przetwarzania identyfikatora pola analizuje identyfikator pojedynczego pola encji w~celu utworzenia na jego podstawie nowego pola widoku lub ustawienia typu już istniejącyego pola.
Wynikiem jego działania jest pole uzyskane na podstawie identyfikatora.

Algorytm przebiega następująco (w~poniższym opsie pominięto obsługę błędów składniowych):

\begin{enumerate}
 \item Jako parametry wejściowe przyjmij identyfikator pola $id_f$ i~widok $v$, do którego ono należy.
 \item Jeśli $v$ nie zawiera pola o~nazwie podanej w~$id_f$, stwórz takie pole $f$ i~dodaj je do $v$; w przeciwnym razie pobierz pole $f$ z~$v$.
 \item Jeśli $id_f$ zawiera definicję typu pola, ustaw na jej podstawie typ pola $f$.
 \item Zwróć $f$.
\end{enumerate}


\subsection{Algorytm przetwarzania relacji} \label{sec:relation_processing}

Algorytm przetwarzania relacji analizuje relacje zidentyfikowane podczas analizy opisu dziedziny.
Celem jego działania jest ustanowienie relacji ``jeden do wielu'' pomiędzy odpowiednimi widokami i~utworzenie nowych widoków reprezentujących relacje ``wiele do wielu''.

Wynikiem działania algorytmu jest uzyskanie ostatecznej listy widoków systemu.
Przetwarzanie przebiega następująco:

\begin{enumerate}
 \item Jako parametry wejściowe przyjmij listę dotychczas utworzonych widoków $V$ i~listę dotychczas utworzonych relacji $R$.
 
 \item Dla każdej relacji ``wiele $v$ do jednego $v'$'' z~$R$, do pól $v$ dodaj wszystkie pola wchodzące w~skład klucza $v'$.
 
 \item Dla każdej relacji $r$ ``jeden $v$ do wielu $v'$'' z~$R$:
  \begin{enumerate}
   \item Jeśli w~$R$ istnieje relacja ``wiele $v$ do wielu $v'$'':
    \begin{itemize}
     \item Stwórz nowy widok $v''$ o~nazwie utworzonej na podstawie nazw $v$ i~$v'$ (np. ``UserPost'' na podstawie relacji ``Jeden $User$ do wielu $Post$'').
     \item Do pól $v''$ dodaj wszystkie pola wchodzące w~skład kluczy $v$ i~$v'$ i~ustaw je jako klucz $v''$.
     \item Do pól $v''$ dodaj wszystkie pola należące do $r$.
     \item Dodaj $v''$ do $V$.
    \end{itemize}
   \item W~przeciwnym razie, do pól $v'$ dodaj wszystkie pola wchodzące w~skład klucza $v$.
  \end{enumerate}
\end{enumerate}



%=======
\section{Kroki postępowania}
%=======



%=======
\section{Podsumowanie}
%=======

- że wystarczający na potrzeby tego systemu
- że gdyby pojedyncze pole miało więcej właściwości, to lipa
- że bardzo business-friendly
