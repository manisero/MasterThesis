\chapter{DSL}

- że ma być czytelne dla człowieka
- że jak najbardziej business-friendly
- że wynik taki sam jak dla opisu w poprzednim rozdziale
- różnica tylko w opisie dziedziny i algorytmie wyodrębniania jednostek generacji (szablony i wszystko inne takie samo)

%=======
\section{Składnia}
%=======

\subsection{Encje i~ich pola}

\begin{itemize}
 \item nazwy encji poprzedzone są znakiem małpy:
  \begin{itemize}
   \item przykład: \verb|@User|;
  \end{itemize}
  
 \item nazwy pól wchodzących w~skład klucza encji wymienione są w~jej identyfikatorze, w~nawiasach okrągłych bezpośrednio po nazwie encji:
  \begin{itemize}
   \item przykład: \verb|@User(UserName)|,
   \item nazwy pól wchodzących w~skład klucza złożonego oddzielone są przecinkami (bez spacji),
   \item klucz encji wystarczy zdefiniować w~jednym (dowolnym) wystąpieniu jej identyfikatora,
   \item w~opisie dziedziny nie mogą wystąpić dwie różne definicje klucza tej samej encji,
   \item definicja klucza encji musi wystąpić przy co najmniej jednym wystąpieniu jej identyfikatora;
  \end{itemize}
 
 \item pola należące do encji występują po jej identyfikatorze, oddzielone od niego znakiem dwukropka:
  \begin{itemize}
   \item przykład: \verb|@User:FirstName|;
  \end{itemize}
  
 \item typ pola podany jest nawiasach kwadratowych bezpośrednio po nazwie pola
  \begin{itemize}
   \item przykłady: \verb|@Post(PostID[id])|, \verb|@Post:CommentsNumber[int]|,
   \item typ pola wystarczy zdefiniować przy jednym (dowolnym) wystąpieniu jego nazwy,
   \item w~opisie dziedziny nie mogą wystąpić dwie różne definicje typu tego samego pola,
   \item polom, których definicja typu nie występuje ani razu, nadawany jest typ $text$;
  \end{itemize}
 
 \item relację ``wiele do jednego'' pomiędzy encjami oznacza się znakiem dwukropka, oddzielającym identyfikatory tych encji:
  \begin{itemize}
   \item przykład: \verb|@Post:@User:FirstName|,
   \item znaczenie: \emph{z~jedną instancją encji} \verb|@User| \emph{powiązanych jest wiele instancji encji} \verb|@Post|;
  \end{itemize}
 
 \item relację ``jeden do wielu'' pomiędzy encjami oznacza się dwoma znakami dwukropka, oddzielającymi identyfikatory tych encji:
  \begin{itemize}
   \item przykład: \verb|@Post::@Comment:Content|,
   \item znaczenie: \emph{z~jedną instancją encji} \verb|@Post| \emph{powiązanych jest wiele instancji encji} \verb|@Comment|.
  \end{itemize}
\end{itemize}

Składnia opisu encji została sformułowana tak, aby była jak najbardziej przystęna dla osoby niebędącej programistą.
Po pierwsze, występują w~niej tylko dwa znaki specjalne: małpa i~dwukropek.
Nie występują też w~niej żadne słowa kluczowe.

Po drugie, informację o~kluczu danej encji czy typie danego pola wystarczy podać raz.
Co więcej, można to zrobić przy dowolnym wystąpieniu danego identyfikatora.
Pozwala to użytkownikowi na samodzielny wybór części opisu dziedziny, w~których zawrze te informacje - mogą to być na przykład najważniejze według niego widoki i~zdarzenia systemu.

Po trzecie, typy pól encji nie są związane z~żadnym konkretnym językiem~(patrz:~\ref{sec:field_type_definition}).
Zostały dobrane tak, aby osoba nieznająca języków programowania nie miała problemów z~ich nadawaniem.
Zestaw typów pól encji obsługiwany przez język to:

\begin{itemize}
 \item $text$ - ciąg znaków; jego odpowiednikiem w~CQL jest również $text$, a~w~C\# - $string$;
 \item $int$ - liczba całkowita; typ ten nazywa się tak samo zarówno w~CQL, jak i~w~C\#;
 \item $id$ - unikalny identyfikator; jego odpowiednikiem w~CQL jest $timeuuid$, a~w~C\# - $Guid$.
\end{itemize}

Jak widać, zestaw typów jest niewielki i~przystępny.
Konieczność używania nazw typów zaczerpniętych z~języka CQL lub C\# mogłaby zniechęcić docelowego użytkownika - w~szczególności typy oznaczające unikalny identyfikator mogłyby być trudne do zrozumienia i~zapamiętania.

Użycie nazw typów niezależnych od języków, w~których tworzony jest system, ma jeszcze jedną zaletę z~punktu widzenia użytkownika, który nie jest programistą.
Możliwe jest używanie tego samego zestawu typów dla wielu systemów, tworzonych w~różnych technologiach.
Użytkownik może pamiętać tylko jeden zestaw typów i~nie musi znać technologii, w~której tworzony jest system, którego dziedzinę definiuje.


\subsection{Zdarzenia}

\begin{itemize}
 \item sekcja definicji zdarzeń następuje w~opisie dziedziny po linii o~treści ``\verb|Events:|'';
 \item definicja pojedynczego zdarzenia składa się z dwóch części:
  \begin{itemize}
   \item nazwy zdarzenia,
   \item opisu zdarzenia, zawierającego identyfikatory i~pola encji wchodzących w~jego skład;
  \end{itemize}
 \item przykład: \verb|Post published: @Post with @Post:Content can be published|;
 \item definicje kolejnych zdarzeń są od siebie oddzielone pustymi liniami.
\end{itemize}

Pojedyncza definicja zdarzenia jednoznacznie określa pojedyncze zdarzenie wchodzące w~skład modelu komend systemu.


\subsection{Widoki}

\begin{itemize}
 \item sekcja definicji widoków następuje w~opisie dziedziny po linii o~treści ``\verb|Views:|'';
 \item definicja widoku to opis zawierający identyfikatory i~pola encji w~nim występujących;
 \item przykład: \verb|I can display @Post with @Post:Title and @Post:Content|;
 \item definicje kolejnych widoków są od siebie oddzielone pustymi liniami.
\end{itemize}

Pojedyncza definicja widoku nie określa jednoznacznie pojedynczego widoku wchodzącego w~skład modelu zapytań systemu.
Określa natomiast treść wyświetlaną na pojedynczym ekranie aplikajcji, co z~biznesowego punktu widzenia jest bardziej intuicyjne.

Model zapytań będzie więc generowany stopniowo na podstawie analizy wszystkich definicji widoków zawartych w~opisie dziedziny.
Po analizie pojedynczej definicji widoku będzie następować aktualizacja całej definicji modelu zapytań.

Należy zwrócić uwagę na fakt, że opisy zdarzeń i~widoków przypominają zdania w~języku naturalnym.
Znacząco zwiększa to przystępność języka dla osób niebędących programistami.


%=======
\section{Przykład}
%=======

(patrz:~\ref{sec:sample_app})

przedstawia rysunek~\ref{fig:dsl:model_dsl}
\input{figures/dsl/model_dsl}

Należy zwrócić uwagę na czytelność i~zwięzłość tego opisu.
Żaden z~przedstawionych wcześniej sposobów opisu dziedziny nie mógł pokazany w~całości na jednej stronie, podczas gdy powyższy opis mieści się bez problemu.



%=======
\section{Algorytm}
%=======

\begin{enumerate}
 \item Stwórz pustą listę widoków $V$, pustą listę relacji $R$ i~pustą listę zdarzeń $E$.
 \item Dla każdej definicji widoku zawartej w~sekcji definicji widoków:
  \begin{enumerate}
   \item Dla każdego identyfikatora $id$ encji występującego w~definicji widoku wykonaj algorytm przetwarzania identyfikatora encji.
  \end{enumerate}
 
 \item Dla każdej definicji zdarzenia zawartej w~sekcji definicji zdarzeń:
  \begin{enumerate}
   \item Stwórz zdarzenie $e$ o~nazwie utworzonej na podstawie nazwy podanej w~defnicji zdarzenia (np. ``PostPublishedEvent'' na podstawie nazwy ``Post published'').
   \item Dla każdego identyfikatora $id$ encji występującego w~opisie zdarzenia:
    \begin{enumerate}
     \item Wykonaj algorytm przetwarzania identyfikatora encji, uzyskując widok $v$ i~pole $f$.
     \item Dodaj $f$ do pól zdarzenia $e$.
    \end{enumerate}
   \item Dodaj $e$ do $E$.
  \end{enumerate}
  
 \item Dla każdej relacji ``wiele $v$ do jednego $v'$'' z~$R$, do pól $v$ dodaj wszystkie pola wchodzące w~skład klucza $v'$.
 
 \item Dla każdej relacji $r$ ``jeden $v$ do wielu $v'$'' z~$R$:
  \begin{enumerate}
   \item Jeśli w~$R$ istnieje relacja ``jeden $v'$ do wielu $v$'':
    \begin{itemize}
     \item Stwórz nowy widok $v''$ o~nazwie utworzonej na podstawie nazw $v$ i~$v'$ (np. ``UserPost'' na podstawie relacji ``Jeden $User$ do wielu $Post$'').
     \item Do pól $v''$ dodaj wszystkie pola wchodzące w~skład kluczy $v$ i~$v'$ i~ustaw je jako klucz $v''$.
     \item Do pól $v''$ dodaj wszystkie pola należące do $r$.
     \item Dodaj $v''$ do $V$.
    \end{itemize}
   \item W~przeciwnym razie, do pól $v'$ dodaj wszystkie pola wchodzące w~skład klucza $v$.
  \end{enumerate}

  \item Zwróć $V$ i~$E$.
\end{enumerate}


\subsection{Algorytm przetwarzania identyfikatora encji}

W~opsie algorytmu pominięto obsługę błędów składniowych.
zwraca widok i pole

\begin{enumerate}
 \item Jako parametry wejściowe przyjmij identyfikator $id$, listę dotychczas utworzonych widoków $V$ i~listę dotychczas utworzonych relacji $R$.
 \item Jeśli $V$ nie zawiera widoku o~nazwie podanej w~$id$, stwórz taki widok $v$ i~dodaj go do $V$; w przeciwnym razie pobierz widok $v$ z~$V$.
 \item Jeśli $id$ zawiera definicję klucza widoku:
  \begin{enumerate}
   \item Stwórz pustą listę pól $F$.
   \item Dla każdego identyfikatora pola $id_f$ podanego w~definicji klucza widoku:
    \begin{enumerate}
     \item Wykonaj algorytm przetwarzania identyfikatora pola, uzyskując pole $f$.
     \item Dodaj $f$ do $F$.
    \end{enumerate}
   \item Ustaw $F$ jako klucz $v$.
  \end{enumerate}
 \item Jeśli $id$ zawiera definicję pola widoku:
  \begin{enumerate}
   \item Wykonaj algorytm przetwarzania identyfikatora pola, uzyskując pole $f$.
   \item Zwróć $v$ i~$f$.
  \end{enumerate}
 \item Jeśli $id$ zawiera definicję relacji (``wiele do jednego'' lub ``jeden do wielu''):
  \begin{enumerate}
   \item Rekurencyjnie wykonaj algorytm dla identyfikatora powiązaniej encji (wraz z~identyfikatorem jej klucza i~pola, jeśli zostały podane), uzyskując widok $v'$ i~pole $f'$.
   \item Jeśli $R$ nie zawiera relacji odpowiedniego typu pomiędzy $v$ i~$v'$, stwórz taką relację $r$ i~dodaj ją do $R$; w przeciwnym razie pobierz relację $r$ z~$R$.
   \item Dodaj $f'$ do $r$.
   \item Zwróć $v$ i~$f'$.
  \end{enumerate}
 \item Zwróć $v$.
\end{enumerate}


\subsection{Algorytm przetwarzania identyfikatora pola}

zwraca pole

\begin{enumerate}
 \item Jako parametry wejściowe przyjmij identyfikator $id_f$ i~widok $v$, do którego ono należy.
 \item Jeśli $v$ nie zawiera pola o~nazwie podanej w~$id_f$, stwórz takie pole $f$ i~dodaj je do $v$; w przeciwnym razie pobierz pole $f$ z~$v$.
 \item Jeśli $id_f$ zawiera definicję typu pola, ustaw na jej podstawie typ pola $f$.
 \item Zwróć $f$.
\end{enumerate}



%=======
\section{Kroki postępowania}
%=======



%=======
\section{Podsumowanie}
%=======

- że wystarczający na potrzeby tego systemu
- że gdyby pojedyncze pole miało więcej właściwości, to lipa
- że bardzo business-friendly
